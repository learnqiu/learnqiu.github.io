{"meta":{"title":"learnQIU","subtitle":null,"description":"冷秋","author":"learnqiu","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2020-12-28T11:13:24.716Z","updated":"2020-12-28T11:13:24.716Z","comments":true,"path":"gallery.json","permalink":"http://example.com/gallery.json","excerpt":"","text":"[{\"name\":\"峨眉山之行\",\"cover\":\"https://i.loli.net/2020/10/05/kBcvAf7INgMLaem.jpg\",\"date\":\"2017-10\",\"description\":\"峨眉山之行\",\"url_name\":\"峨眉山之行\",\"album\":[{\"img_url\":\"https://i.loli.net/2020/10/05/qtOevHpw5XImS1J.jpg\",\"title\":\"峨眉山之行\",\"describe\":\"峨眉山之行\"},{\"img_url\":\"https://i.loli.net/2020/10/05/4acvniMKTx8euqp.jpg\",\"title\":\"峨眉山之行\",\"describe\":\"峨眉山之行\"},{\"img_url\":\"https://i.loli.net/2020/10/05/4acvniMKTx8euqp.jpg\",\"title\":\"峨眉山之行\",\"describe\":\"峨眉山之行\"}]}]"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-12-19T15:46:46.325Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"[冷秋] 与&nbsp; learnQIU&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-12-23T05:03:54.889Z","comments":false,"path":"bangumi/index.html","permalink":"http://example.com/bangumi/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-03-09T05:50:05.000Z","updated":"2020-12-15T13:36:07.868Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-12-19T15:09:21.148Z","comments":false,"path":"client/index.html","permalink":"http://example.com/client/index.html","excerpt":"","text":"直接下载 or 扫码下载："},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-12-19T15:09:29.057Z","comments":true,"path":"comment/index.html","permalink":"http://example.com/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》"},{"title":"gallery","date":"2020-12-28T11:07:21.000Z","updated":"2020-12-28T11:07:50.100Z","comments":true,"path":"gallery/index.html","permalink":"http://example.com/gallery/index.html","excerpt":"","text":""},{"title":"donate","date":"2020-12-14T15:13:05.000Z","updated":"2020-12-20T06:06:53.334Z","comments":false,"path":"donate/index.html","permalink":"http://example.com/donate/index.html","excerpt":"","text":""},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-12-19T15:09:46.127Z","comments":false,"path":"lab/index.html","permalink":"http://example.com/lab/index.html","excerpt":"","text":"sakura主题balabala"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-12-20T06:19:56.184Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-12-19T15:12:04.042Z","comments":false,"path":"music/index.html","permalink":"http://example.com/music/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-12-14T02:15:33.698Z","comments":true,"path":"rss/index.html","permalink":"http://example.com/rss/index.html","excerpt":"","text":""},{"title":"shuoshuo","date":"2020-12-23T07:09:38.472Z","updated":"2020-12-23T07:09:38.472Z","comments":false,"path":"shuoshuo/index.html","permalink":"http://example.com/shuoshuo/index.html","excerpt":"","text":"new Artitalk({ appId: '5OP5QaruBdEJ4SL0Xx4j3oEk-gzGzoHsz', // Your leancloud appId appKey: 'pjqBQAhK38HG6fE4Sg2YHjsw', // Your leancloud appKey serverURL: 'www.learnqiu.top' })"},{"title":"tags","date":"2020-12-15T13:25:51.000Z","updated":"2020-12-15T13:25:51.493Z","comments":false,"path":"tags/index-1.html","permalink":"http://example.com/tags/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2020-12-15T13:28:05.000Z","updated":"2020-12-15T13:28:55.016Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-12-14T02:15:33.700Z","comments":false,"path":"theme-sakura/index.html","permalink":"http://example.com/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-12-14T02:15:33.701Z","comments":false,"path":"video/index.html","permalink":"http://example.com/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }"},{"title":"个人随拍","date":"2020-12-28T11:09:21.000Z","updated":"2020-12-28T11:10:10.747Z","comments":true,"path":"gallery/个人随拍/index.html","permalink":"http://example.com/gallery/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E6%8B%8D/index.html","excerpt":"","text":""},{"title":"生活碎片","date":"2020-12-28T11:09:21.000Z","updated":"2020-12-28T11:10:22.681Z","comments":true,"path":"gallery/生活碎片/index.html","permalink":"http://example.com/gallery/%E7%94%9F%E6%B4%BB%E7%A2%8E%E7%89%87/index.html","excerpt":"","text":""}],"posts":[{"title":"word常用操作总结","slug":"tech-paper-rel-01","date":"2021-04-11T05:44:49.000Z","updated":"2022-03-12T14:29:55.690Z","comments":true,"path":"posts/archives/40673.html/","link":"","permalink":"http://example.com/posts/archives/40673.html/","excerpt":"","text":"1.word怎样从第三页开始设置页码来自http://www.360doc.com/content/18/1211/14/35329290_801017306.shtml 一般的文件都是有封面、目录、然后才是正文。所以基本上第一页的封面，第二页是目录，第三页才是正文的开始。但是默认的页码会从第一页开始，封面上有页码这会很难看，今天和小编一起来看看怎样将页码从第三页开始。要想成功从第三页插入页码？“分隔符”是关键！ 1、点击【插入】→【页眉和页脚】→【页码】-【页面底端】选择一种样式的页码。 2、文档开始出现页码，但是是从第一页开始的。 3、将光标定位到第二页文章末尾处，点击【布局】→【页面设置】→【分隔符】→【下一页】。 4、如果要从第四页或者第五开始设置页码，就把光标定位到设置页码的前一页。 5、第三页变成了空白页，但是页码是：1 6、点击【插入】→【页眉和页眉】→【页码】→【设置页码格式】 7、然后再弹出页码格式对话框中，页码编号下面，勾选【起始页码】对输入框里面输入 1 8、双击第三页上的页码，进入编辑状态。点击【设计】→【链接到前一条页眉】，【链接到前一条页眉】是已选状态，我们点击一下将其取消选择。 9、删除第三页（也就是插入分节符时生成的空白页） 10、双击第一页第二页上的页码，然后删除。 11、现在看文档的时候就会发现页码是从第三页开始的了 2.word自动生成目录后，为什么上面不能写字因为目录上方的格式同目录的段落格式一样.只要右键段落，将其设置成正文或其它格式就可以. 3.在word中怎么实现奇数页页眉用本章标题，偶数页用论文标题？来自https://zhidao.baidu.com/question/2052967548185182227.html更多回答 在word中，可以通过下面的设置，实现奇数页页眉用本章标题，偶数页用论文标题。 1、单击页面布局选项卡右下角如图所示的按钮； 2、弹出页面设置对话框，选择版式选项卡，在页眉和页脚处，选中奇偶页不同复选框； 3、将光标定位在章标题处，单击开始—-样式1按钮，将章标题设置成标题样式； 4、在奇数页的页眉处双击鼠标，进入页眉编辑状态； 5、单击插入文档部件—-域； 6、弹出域对话框，在类别处选择链接和引用；在域名处选择StyleRet，在样式名处选择标题1即可，如图所示。 7、将光标定位在偶数页页眉处，输入论文标题即可。 4.如何在word中插入图表目录（插图清单、表格清单）1.首先将需要整理目录的图像下面的文字标题复制 2.然后将鼠标选择图/表 3.找到引用-&gt; 插入题注-&gt;新建标签（因为需要标注图1.几），输入图1，点击确定。 4.这时候标签中有图1了，找到图1，题注中自动生成图1.1，将之前复制的语句粘贴上，或者自己写上图1.1 +描述即可。 5.相应地，在引用-&gt;插入表目录，在图表目录中修改相应的参数，点击确定即可。 5.word图表目录多个标题之间的空行无法删除在空行的上一个目录标题尾部按Delete键，即可删除空行。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"word","slug":"word","permalink":"http://example.com/tags/word/"}],"author":"learnqiu"},{"title":"荣耀面经","slug":"tech-honor-01","date":"2021-03-31T10:51:38.000Z","updated":"2021-04-28T13:01:30.272Z","comments":true,"path":"posts/archives/36987.html/","link":"","permalink":"http://example.com/posts/archives/36987.html/","excerpt":"","text":"荣耀面经面经01作者：牛客240082929号链接：https://www.nowcoder.com/discuss/612951?source_id=profile_create_nctrack&amp;channel=-1来源：牛客网 通用软件开发 一面 ：完完全全的八股文，面试官是java方向，最后是做一个自我介绍。。。。 时间总过20分钟左右背了一堆八股文。。。。基本确定是kpi面了。。。 二面：主管面，面试官人真好，不管能不能进荣耀我都要说真的面试体验太好了，还会给你指导技术问题hhh，我还问了我的代码bug（虽然他也说不准hhhh体验确实好，荣耀真是我体验最好的面试了hhh","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"面试准备","slug":"面试准备","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"}],"author":"learnqiu"},{"title":"学习笔记：spring-boot","slug":"tech-spring-boot-01","date":"2021-03-30T07:01:50.000Z","updated":"2021-03-30T07:04:48.736Z","comments":true,"path":"posts/archives/30767.html/","link":"","permalink":"http://example.com/posts/archives/30767.html/","excerpt":"","text":"学习笔记：spring-boot","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"learnqiu"},{"title":"讯飞面经","slug":"tech-xunfei-01","date":"2021-03-28T13:38:19.000Z","updated":"2021-03-30T07:04:48.783Z","comments":true,"path":"posts/archives/47022.html/","link":"","permalink":"http://example.com/posts/archives/47022.html/","excerpt":"","text":"讯飞面经作者：好圆链接：https://www.nowcoder.com/discuss/605305?channel=-1&amp;source_id=profile_follow_post_nctrack来源：牛客网 面经01 1.OSI七层模型介绍 ​ OSI七层模型是国际标准化组织（ISO）制定的一个用于计算机或通讯系统间互联的标准体系 应用层：为计算机用户提供应用接口，也为用户直接提供各种网络服务。 表示层：提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。 会话层：就是负责建立、管理和终止表示层实体之间的通信会话。 传输层：建立了主机端到端的链接。 网络层：通过IP寻址来建立两个节点之间的连接。 数据链路层 ：将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。 物理层 ： 实际最终信号的传输是通过物理层实现的。 2.Java八种基本数据类型 ​ byte、short、int、long、float、double、boolean、char 3.Java常用的容器类介绍 ​ Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。 Collection：一个独立元素的序列，这些元素都服从一条或者多条规则。 ​ (list有序可重复，set无序不可重复) Map：一组成对的“键值对”对象，允许你使用键来查找值。 继承结构图 遍历方法 import java.util.*; public class Test&#123; public static void main(String[] args) &#123; List&lt;String&gt; list=new ArrayList&lt;String&gt;(); list.add(&quot;Hello&quot;); list.add(&quot;World&quot;); list.add(&quot;HAHAHAHA&quot;); //第一种遍历方法使用 For-Each 遍历 List for (String str : list) &#123; //也可以改写 for(int i=0;i&lt;list.size();i++) 这种形式 System.out.println(str); &#125; //第二种遍历，把链表变为数组相关的内容进行遍历 String[] strArray=new String[list.size()]; list.toArray(strArray); for(int i=0;i&lt;strArray.length;i++) //这里也可以改写为 for(String str:strArray) 这种形式 &#123; System.out.println(strArray[i]); &#125; //第三种遍历 使用迭代器进行相关遍历 Iterator&lt;String&gt; ite=list.iterator(); while(ite.hasNext())//判断下一个元素之后有值 &#123; System.out.println(ite.next()); &#125; &#125; &#125; import java.util.*; public class Test&#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(&quot;1&quot;, &quot;value1&quot;); map.put(&quot;2&quot;, &quot;value2&quot;); map.put(&quot;3&quot;, &quot;value3&quot;); //第一种：普遍使用，二次取值 System.out.println(&quot;通过Map.keySet遍历key和value：&quot;); for (String key : map.keySet()) &#123; System.out.println(&quot;key= &quot;+ key + &quot; and value= &quot; + map.get(key)); &#125; //第二种 System.out.println(&quot;通过Map.entrySet使用iterator遍历key和value：&quot;); Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = it.next(); System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue()); &#125; //第三种：推荐，尤其是容量大时 System.out.println(&quot;通过Map.entrySet遍历key和value&quot;); for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue()); &#125; //第四种 System.out.println(&quot;通过Map.values()遍历所有的value，但不能遍历key&quot;); for (String v : map.values()) &#123; System.out.println(&quot;value= &quot; + v); &#125; &#125; &#125; 如何使用比较器 TreeSet和TreeMap的按照排序顺序来存储元素. 然而，这是通过比较器来精确定义按照什么样的排序顺序 使用 Java Comparator‘ 4.HashMap结构 引申到数组和链表操作的时间复杂度 无序数组 有序数组 有序链表（失去了链表插入快的特性） 无序链表 如何解决哈希冲突 HashMap根据名称可知，其实现方法与Hash表有密切关系。 数组：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n) 线性链表：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n) 二叉树：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。 哈希表：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)**，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。 哈希表原理 数据结构的物理存储结构只有两种：顺序存储结构和链式存储结构（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，哈希表的主干就是数组。 比如我们要新增或查找某个元素，我们通过把当前元素的关键字，通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。 location = hash(关键字)其中，hash函数设计的优劣直接影响整体的性能。 哈希冲突 哈希算法存在一个缺点就是哈希冲突。进行数据存储时，我们通过对关键字进行hash时得到的地址已经存储过数据了，这时就会出现哈希冲突。哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，建立公共溢出区法，链地址法，而HashMap即是采用了链地址法，也就是数组+链表的方式。 hashMap工作原理，put,get,hashcode,equal 发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。 查找算法 1. 顺序查找 2. 二分查找 3. 插值查找 4. 斐波那契查找 5. 树表查找 6. 分块查找 7. 哈希查找 什么时候发生死锁 死锁是指这样一种情况：多个线程同时被阻塞，它们中的一个或者全部在等待某个资源被释放或者是都是处于等待而无法被唤醒时，由于线程被无限地阻塞，因此程序不能正常终止。 产生死锁的必要条件： 互斥条件：在一段时间内某资源仅为一进程所占用。请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。循环等待条件：在发生死锁时，必然存在一个进程–资源的环形链。 锁类型 可重入锁：在执行对象中所有同步方法不用再次获得锁 可中断锁：在等待获取锁过程中可中断 公平锁： 按等待获取锁的线程的等待时间进行获取，等待时间长的具有优先获取锁权利 读写锁：对资源读取和写入的时候拆分为2部分处理，读的时候可以多线程一起读，写的时候必须同步地写 synchronied与Lock区别 5.Java多线程 线程池的种类 newCachedThreadPool创建一个可缓存线程池程 newFixedThreadPool 创建一个定长线程池 newScheduledThreadPool 创建一个周期性执行任务的线程池 newSingleThreadExecutor 创建一个单线程化的线程池 https://blog.csdn.net/weichi7549/article/details/108300621 多线程几种方法 1.继承Thread类，重写run方法2.实现Runnable接口，重写run方法，实现Runnable接口的实现类的实例对象作为Thread构造函数的target3.通过Callable和FutureTask创建线程4.通过线程池创建线程 https://blog.csdn.net/java_zyq/article/details/87917734 6.JVM相关 JVM内存分区 ​ 方法区：JVM方法区是用于保存已经被虚拟机加载的类元信息（包括类的版本、字段、方法、接口和父类等信息）、运行时常量信息(static、final定义的常量)、字符串常量信息(String a=”dfc”)。 虚拟机栈：栈这部分区域主要是用于线程运行方法的区域，此区域属于线程私有的空间，每一个线程创建后都会申请一个自己单独的栈空间，每一个方法的调用都会对应着一个栈帧。 本地方法栈：由于java需要与一些底层系统如操作系统或某些硬件交换信息时的情况，这个时候就需要通过调用native本地方法来实现，本地方法栈和虚拟机栈功差不多，区别在于本地方法栈是虚拟机调用native方法时使用的。 程序计数器：程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器，程序计数器记录着某个线程当前执行指令的位置，此区域属于线程隔离区。 堆：堆内存主要是用来存放创建的对象数据，此区域属于线程共享区对于开发人员来说这块区域是我们关注的比较多，因为很多优化都是针对这块区域来进行的，为了能更清楚的描述堆里的数据和分区信息，所以会结合垃圾回收的一些机制来描述这块内存区域。堆-&gt;新生代和老年代划分机制：堆内存主要是用来存放我们运行过程中创建的对象数据，根据对象所生存时间长短的特性在逻辑上分为 新生代和老年代。 堆-&gt;Eden区和 Survior 划分机制:所以为了减少这种空间碎片，我们就使用了另一种方式，把新生代分为了Eden 区和Survior 区，在进行垃圾回收时，先把存活的对象复制到 Survior 区，然后再对Eden区统一进行清理，这样的话Eden区每次GC过后都是留下的一片连续的空间 堆-&gt;S1 区和S2区划分机制:上面我们把新生代划分为Eden区和Survior区后，空间碎片问题好像改善了很多，因为这样解决了Eden区的空间碎片问题，但是这样的话我们忽略了一个问题，空间碎片问题Survior 区也会存在，因为进行GC时，我们Survior 区也会有垃圾对象，所以每次GC也会对Survior 区进行标记清除，那么这样的话Survior 区也同样会出现不连续的空间。 最后经过了一些特定区域职责划分后，堆内存划分为 老年代、新生代，新生代又划分为Eden区、s1区、s2区域。 https://zhuanlan.zhihu.com/p/111370230 7.重写和重载 https://www.pianshen.com/article/18371043326/ 8.面向对象的特点 https://blog.csdn.net/web874418927/article/details/50725994 三大基本特征 封装,继承,多态 封装：也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 继承：可以让某个类型的对象获得另一个类型的对象的属性的方法。 多态：一个类实例的相同方法在不同情形有不同表现形式。 五大基本原则 单一职责原则、开放封闭原则、替换原则、依赖原则、接口分离原则 开闭原则：对拓展开放，对修改关闭。 里氏代换原则：可以实现子父类互相替换； 依赖反转原则：针对接口编程，实现开闭原则的基础； 接口隔离原则：降低耦合度，接口单独设计，互相隔离； 单一职责原则：一个类的功能要单一，不能包罗万象。 9.普通方法和构造方法区别 1、构造方法的名字必须与定义他的类名完全相同，没有返回类型，甚至连void也没有。 2、类中必定有构造方法，若不写，系统自动添加无参构造方法。接口不允许被实例化，所以接口中没有构造方法。 3、不能被static、final、synchronized、abstract和native修饰。 4、构造方法在初始化对象时自动执行,一般不能显式地直接调用、当同一个类存在多个构造方法时，java编译系统会自动按照初始化时最后面括号的参数个数以及参数类型来自动一一对应。完成构造函数的调用。 5、构造方法分为两种：无参构造方法 有参构造方法。 ​ https://blog.csdn.net/weixin_34779181/article/details/114043567 10.SQL相关 索引失效的情况 1、like的模糊查询以%开头2、条件中用or，即使其中有条件带索引，也不会使用索引查询3、查询条件如果是字符串，不加引号会使索引失效4、not null 不会使用索引， is null 会使用索引5、使用 &lt;&gt; 或者!=6、in not in7、在索引列上使用计算 避免索引失效 避免使用*通配符“%”或者“_”作为查询字符串的第一个字符在设计表时，把索引列设置为NOT NULLWhere子句中避免在索引列上使用计算索引列上进行函数操作，索引失效用&gt;= 代替 &gt; 尽量不使用 &lt;&gt; 或者!=使用EXISTS代替 in 用not EXISTS 代替 not in like中百分号%的位置 “%” 可用于定义通配符（模式中缺少的字母） LIKE &#39;N%&#39; 以 &quot;N&quot; 开始 LIKE &#39;%g&#39; 以 &quot;g&quot; 结尾 LIKE &#39;%lon%&#39; 包含 &quot;lon&quot; NOT LIKE &#39;%lon%&#39; 不包含 &quot;lon&quot; LIKE &#39;_eorge&#39; 第一个字符之后是 &quot;eorge&quot; LIKE &#39;C_r_er&#39; 以 &quot;C&quot; 开头，然后是一个任意字符，然后是 &quot;r&quot;，然后是任意字符，然后是 &quot;er&quot; LIKE &#39;[ALN]%&#39; 以 &quot;A&quot; 或 &quot;L&quot; 或 &quot;N&quot; 开头 LIKE &#39;[!ALN]%&#39; 不以 &quot;A&quot; 或 &quot;L&quot; 或 &quot;N&quot; 开头 外键相关 CREATE TABLE Orders ( Id_O int NOT NULL, OrderNo int NOT NULL, Id_P int, PRIMARY KEY (Id_O), FOREIGN KEY (Id_P) REFERENCES Persons(Id_P) ) DROP FOREIGN KEY fk_PerOrders 数据库三大范式 列不可再分 属性完全依赖于主键 不产生传递依赖 ​ 三大范式只是一般设计数据库的基本理念，可以建立冗余较小、结构合理的数据库。如果有特殊情况，当然要特殊对待，数据库设计最重要的是看需求跟性能，需求&gt;性能&gt;表结构。所以不能一味的去追求范式建立数据库。实际情况会出现以空间换时间的情况。 左连接和右连接 左连接 where只影向右表，右连接where只影响左表。 inner join：理解为“有效连接”，两张表中都有的数据才会显示 left join：理解为“有左显示”，比如on a.field=b.field，则显示a表中存在的全部数据及a\\b中都有的数据，A中有、B没有的数据以null显示 right join：理解为“有右显示”，比如on a.field=b.field，则显示B表中存在的全部数据及a\\b中都有的数据，B中有、A没有的数据以null显示 full join：理解为“全连接”，两张表中所有数据都显示，实际就是inner +(left-inner)+(right-inner) 11.Redis常见数据类型 Redis介绍 ​ 一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的key-value 键值对存储系统，是跨平台的非关系型数据库。 ​ Redis 通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型。 ​ Redis有着更为复杂的数据结构，Redis运行在内存中但是可以持久化到磁盘 Java中使用Redis 安装 Java redis 驱动-&gt; jedis-2.9.0.jar 连接 redis服务 import redis.clients.jedis.Jedis; public class RedisJava &#123; public static void main(String[] args) &#123; //连接本地的 Redis 服务 Jedis jedis = new Jedis(&quot;localhost&quot;); // 如果 Redis 服务设置来密码，需要下面这行，没有就不需要 // jedis.auth(&quot;123456&quot;); System.out.println(&quot;连接成功&quot;); //查看服务是否运行 System.out.println(&quot;服务正在运行: &quot;+jedis.ping()); &#125; &#125; Redis Java String(字符串) /List(列表)/Keys实例 import redis.clients.jedis.Jedis; public class RedisStringJava &#123; public static void main(String[] args) &#123; //连接本地的 Redis 服务 Jedis jedis = new Jedis(&quot;localhost&quot;); System.out.println(&quot;连接成功&quot;); //设置 redis 字符串数据 jedis.set(&quot;runoobkey&quot;, &quot;www.runoob.com&quot;); // 获取存储的数据并输出 System.out.println(&quot;redis 存储的字符串为: &quot;+ jedis.get(&quot;runoobkey&quot;)); //存储数据到列表中 jedis.lpush(&quot;site-list&quot;, &quot;Runoob&quot;); jedis.lpush(&quot;site-list&quot;, &quot;Google&quot;); jedis.lpush(&quot;site-list&quot;, &quot;Taobao&quot;); // 获取存储的数据并输出 List&lt;String&gt; list = jedis.lrange(&quot;site-list&quot;, 0 ,2); for(int i=0; i&lt;list.size(); i++) &#123; System.out.println(&quot;列表项为: &quot;+list.get(i)); &#125; // 获取数据并输出 Keys Set&lt;String&gt; keys = jedis.keys(&quot;*&quot;); Iterator&lt;String&gt; it=keys.iterator() ; while(it.hasNext())&#123; String key = it.next(); System.out.println(key); &#125; &#125; 12.Spring相关 MyBatis介绍 MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 SpringBoot介绍 Spring是Java企业版（Java Enterprise Edition，JEE，也称J2EE）的轻量级代替品。无需开发重量级的EnterpriseJavaBean（EJB），Spring为企业级Java开发提供了一种相对简单的方法，通过依赖注入和面向切面编程，用简单的Java对象（Plain Old Java Object，POJO）实现了EJB的功能。 1.使用Spring的IOC容器,将对象之间的依赖关系交给Spring,降低组件之间的耦合性,让我们更专注于应用逻辑 2.可以提供众多服务,事务管理,WS等。 3.AOP的很好支持,方便面向切面编程。 4.对主流的框架提供了很好的集成支持,如Hibernate,Struts2,JPA等 5.Spring DI机制降低了业务对象替换的复杂性。 6.Spring属于低侵入,代码污染极低。 7.Spring的高度可开放性,并不强制依赖于Spring,开发者可以自由选择Spring部分或全部 Spring的缺点 虽然Spring的组件代码是轻量级的，但它的配置却是重量级的.所有这些配置都代表了开发时的损耗。 项目的依赖管理也是一件耗时耗力的事情。 jsp中要写很多代码、控制器过于灵活,缺少一个公用控制器 Spring不支持分布式,这也是EJB仍然在用的原因之一。 SpringBoot解决上述Spring的缺点 ​ SpringBoot对上述Spring的缺点进行的改善和优化，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度上缩短了项目周期。 SpringBoot的特点 为基于Spring的开发提供更快的入门体验 开箱即用，没有代码生成，也无需XML配置。同时也可以修改默认值来满足特定的需求 提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康检测、外部配置等 SpringBoot不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式 SpringBoot的核心功能 起步依赖 起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依 赖，这些东西加在一起即支持某项功能。 简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。 自动配置 Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定Spring配置应该用哪个，不该用哪个。该过程是Spring自动完成的。 MVC结构的解释 MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。 Model（模型） - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。 View（视图） - 视图代表模型包含的数据的可视化。 Controller（控制器） - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。 控制反转和依赖注入 Spring框架的人一定都会听过Spring的**IoC(控制反转) 、DI(依赖注入)**这两个概念 IoC(控制反转):是一种设计思想，在Java开发中,Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。 ​ ●谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；**谁控制谁？当然是IoC容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）\\。** ●为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。 IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。 其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。 IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。 依赖注入 ​ 组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。 理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下： ●谁依赖于谁：当然是应用程序依赖于IoC容器； ●为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源； ●谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象； ●注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。 ​ IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。 依赖注入的常见方式 构造方法注入 如果只有一个有参数的构造方法并且参数类型与注入的bean的类型匹配，那就会注入到该构造方法中。 Setter注入 在XML中写入，然后在set方法中注入。 基于注解的注入 @Autowired（自动注入）修饰符有三个属性：Constructor，byType，byName。默认按照byType注入。 面经02 作者：煎饼果子这个名字已经被占用了链接：https://www.nowcoder.com/discuss/621122?channel=-1&amp;source_id=profile_follow_post_nctrack来源：牛客网 时间 ： 20min plus: 我卡着点进来了 进来的时候面试官已经进来了(QAQ) 自我介绍 说道使用springboot redis之类 springboot启动过程说一下 1.新建module,在主程序类加入断点,启动springboot。 2.首先进入SpringAplication类run方法。 3.run方法新建SpringApplication对象。 4.SpringApplication对象的run方法。 5.run方法首先创建并启动计时监控类。 SpringBootApplication注解由哪几个注解组成 @Configuration： 用于定义一个配置类 @EnableAutoConfiguration ：Spring Boot会自动根据你jar包的依赖来自动配置项目。 @ComponentScan： 告诉Spring 哪个packages 的用注解标识的类 会被spring自动扫描并且装入bean容器。 Redis缓存击穿，如何解决(不懂) 缓存击穿，是指对那些会失效的key有高并发的请求，然后在失效的那一瞬间，高并发请求来了，读不到redis的值，全都会把请求打到数据库，导致数据库压力过大 解决方案1、分布式锁当发现缓存失效的时候，先使用setnx设置分布式锁，只有获取锁成功的那个线程可以查数据库并回写缓存。 优点：能解决问题。 缺点：1、如果不支持原子操作的话，这个setnx的分布式锁可能会发生死锁。2、性能一般 2、本地锁同上，只是使用本地锁，解决死锁问题。 优点：没有死锁问题 缺点：有多少个机器实例，最多就有多少个“查数据库然后回写redis”的操作 3、软过期把过期时间写在value中，当读到的时候，发现过期的时候，立马更新过期时间，然后再读数据库、回写。 优点：没有死锁问题 缺点：所谓的“立马”更新过期时间，其实也不是原子性的，高并发的时候会有大量的线程认为过期，然后去读数据库。其实也没完全解决大量查数据库的问题，只是减少了查数据库的量。 用的是哪个版本的jdk ? 答1.8 问 ：说一下1.8的新特性 Lambda表达式 函数式接口 *方法引用和构造器调用 Stream API 接口中的默认方法和静态方法 新时间日期API jvm垃圾收集 参数设置 如何打印线程堆栈信息 性能调优做过么(没做过) 、 垃圾回收算法 1、标记-清除算法（Mark-Sweep） 2、复制算法（Copying）（针对新生代） 3、标记-整理算法（Mark-Compact）（针对老年代） 4、分代收集算法（Generational Collection） 垃圾收集器 1、Serial收集器（用于新生代） 2、ParNew收集器（新生代） 3、Parallel Scavenge收集器（“吞吐量优先”收集器）（新生代） 4、Serial Old收集器（老年代） 5、Parallel Old收集器（老年代） 6、CMS收集器（Concurrent Mark Sweep） 7、G1收集器（Garbage First） 参数总结 UseSerialG 虚拟机运行在client模式下的默认值，打开此开关后，使用Serial+SerialOld的收集器组合进行内存回收。 UserParNewGC 使用ParNew+Serial Old的收集器组合进行内存回收 UserConMarkSweepGC： 使用ParNew+CMS+Serial Old的收集器组合进行内存回收。Serial Old收集器将作为CMC收集器出现Concurrent Mode Fail失败后的后被收集处理器使用 UserParallelGC： 虚拟机运行在client模式下的默认值，使用Parallel Scavenge+Serial Old （ps MarkSweep）的收集器组合进行内存回收 UserParallelOldGC 使用Parallel+Scavenge+Parallel Old的收集器进行内存回收 SurvivorRatio 新生代中Eden区域与Survivior区域的容量比值，默认为8，代表Eden：Survicor = 8:1 PretenureSizeThreshold 直接晋升老年代对象的大小，设置这个参数后，大于这个参数的对象将直接在老年代分配。 MaxTenuringThreshold 晋升老年代的对象年龄，每个对象在坚持一次Minor GC之后，年龄就增加，当超过这个参数值时就进入老年代 UseAdaptiveSizePolicy 动态调整java堆中各个区域的大小以及进入老年代的年龄 HandlePromotionFailure 是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和survivor区的所有对象都存活的极端情况 ParallelGCThreads 设置并行GC时进行内存回收的线程数 GCTimeRatio GC时间占总时间的比率，默认值为99，即允许百分之一的GC时间，仅在使用Parallel Scavenge收集器时生效 MaxGCPauseMills 设置GC的最大停顿时间，仅在使用Parallel Scavenge收集器时生效 CMSInitiatingOccupancyFraction 设置CMS收集器在老年代空间被使用多少后触发垃圾收集。默认值为百分之68，仅在使用CMS收集器时生效 UseCMSCompactAtFullCollection 设置CMS收集器在完成垃圾收集后是否进行一次内存碎片整理，仅在使用CMS收集器时生效 CMSFullGCsBeforeCompaction 设置CMS收集器在进行若干次垃圾收集后在启动一次内存碎片整理。仅在使用CMS收集器时生效 创建多线程和关闭线程的方式 继承Thread类创建线程 1】定义Tread类的子类MyThread，并重写run()方法.run()方法的方法体（线程执行体）就是线程要执行的任务。 2】创建MyThread类的实例 3】调用子类实例的start()方法来启动线程 实现Runnable接口创建线程 1】定义Runnable接口的实现类，必须重写run(）方法，这个run()方法和Thread中的run()方法一样，是线程的执行体 2】创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象 3】调用start()方法 使用Callable和Future创建线程 1】call方法可以有返回值 2】call()方法可以声明抛出异常 使用线程池创建（使用java.util.concurrent.Executor接口） 继承Thread与实现接口的区别 1】线程只是实现Runnable或实现Callable接口，还可以继承其他类。 2】这种方式下，多个线程可以共享一个target对象，非常适合多线程处理同一份资源的情形。 3】继承Thread类只需要this就能获取当前线程。不需要使用Thread.currentThread()方法 4】继承Thread类的线程类不能再继承其他父类（Java单继承决定）。 5】前三种的线程如果创建关闭频繁会消耗系统资源影响性能，而使用线程池可以不用线程的时候放回线程池，用的时候再从线程池取，项目开发中主要使用线程池的方式创建多个线程。 6】实现接口的创建线程的方式必须实现方法（run() call()）。 排序算法 冒泡是稳定排序么 堆排序是稳定排序呢 堆排序空间复杂度 ​ 选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法 有什么你比较强的领域我没问的么(答 没有QAQ) 没有反问阶段 面试官说面试完毕 等待通知 面经03作者：找不到工作就去当网管链接：https://www.nowcoder.com/discuss/611171?channel=-1&amp;source_id=profile_follow_post_nctrack来源：牛客网 一面大概三十分钟 jvm的内存模型，垃圾回收策略，类加载机制 垃圾回收策略-》垃圾回收算法 类加载机制 Java 的类加载过程可以分为 5 个阶段：载入、验证、准备、解析和初始化。这 5 个阶段一般是顺序发生的，但在动态绑定的情况下，解析阶段发生在初始化阶段之后。 1）Loading（载入） ​ 将字节码从不同的数据源（可能是 class 文件、也可能是 jar 包，甚至网络）转化为二进制字节流加载到内存中，并生成一个代表该类的 java.lang.Class 对象。 2）Verification（验证） ​ JVM 会在该阶段对二进制字节流进行校验，只有符合 JVM 字节码规范的才能被 JVM 正确执行。该阶段是保证 JVM 安全的重要屏障，下面是一些主要的检查。 3）Preparation（准备）、 ​ JVM 会在该阶段对类变量（也称为静态变量，static 关键字修饰的）分配内存并初始化（对应数据类型的默认初始值，如 0、0L、null、false 等）。 4）Resolution（解析） ​ 该阶段将常量池中的符号引用转化为直接引用。 5）Initialization（初始化） ​ 该阶段是类加载过程的最后一步。在准备阶段，类变量已经被赋过默认初始值，而在初始化阶段，类变量将被赋值为代码期望赋的值。换句话说，初始化阶段是执行类构造器方法的过程。 类加载器 1）启动类加载器（Bootstrap Class-Loader），加载 jre/lib 包下面的 jar 文件，比如说常见的 rt.jar。 2）扩展类加载器（Extension or Ext Class-Loader），加载 jre/lib/ext 包下面的 jar 文件。 3）应用类加载器（Application or App Clas-Loader），根据程序的类路径（classpath）来加载 Java 类。 hashmap1.7和1.8区别，put方法，为什么线程不安全 1.底层结构不一样，1.7是数组+链表，1.8则是数组+链表+红黑树结构; jdk1.7中当哈希表为空时，会先调用inflateTable()初始化一个数组；而1.8则是直接调用resize()扩容; 插入键值对的put方法的区别，1.8中会将节点插入到链表尾部，而1.7中是采用头插； redis的基本数据类型，数据淘汰策略，哨兵模式，字典表，redis的底层 springboot的常用注解，为什么可以自动注入bean 前端框架了解哪些 跨域问题，九大内置对象（这个就答上了几个，都忘了） mysql的索引有哪些，索引失效情况 es的倒排索引，分片和副本是什么 讲一下冒泡排序 如何最快查找出两个list集合中重复的数据 最近看过什么书 沟通表达能力怎么样","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"面试准备","slug":"面试准备","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"}],"author":"learnqiu"},{"title":"华为面经","slug":"tech-huaweiC-01","date":"2021-03-25T12:58:23.000Z","updated":"2021-03-30T07:04:48.759Z","comments":true,"path":"posts/archives/25291.html/","link":"","permalink":"http://example.com/posts/archives/25291.html/","excerpt":"","text":"设计模式1.创建型模式**–&gt;**对象怎么来​ 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 **工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式** 2.结构型模式**–&gt;**对象和谁有关​ 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 ​ 适配器模式、桥接模式、过滤器模式、组合模式、装饰器模式、外观模式、享元模式、代理模式 3.行为型模式**–&gt;**对象与对象在干嘛​ 这些设计模式特别关注对象之间的通信。 ​ 责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、空对象模式、策略模式、模板模式、访问者模式 4.J2EE模式**–&gt;**对象合起来要干嘛 MVC 模式、业务代表模式、组合实体模式、数据访问对象模式、前端控制器模式、拦截过滤器模式、服务定位器模式、传输对象模式 设计模式六大原则 开闭原则：实现热插拔，提高扩展性。 里氏代换原则：实现抽象的规范，实现子父类互相替换； 依赖反转原则：针对接口编程，实现开闭原则的基础； 接口隔离原则：降低耦合度，接口单独设计，互相隔离； 最少知道原则：功能模块尽量独立； 合成复用原则：尽量使用聚合，组合，而不是继承； 七大原则记忆口诀：开口里合最单依 开：开闭原则 口：接口隔离原则 里：里氏替换原则 合：合成复用原则 最：最少知道原则 单：单一职责原则 依：依赖倒置原则 精华问题 算法题 ，给定一个数组和目标值，求数组中满足两数之和等于目标值的下标对，若不存在满足条件的对则返回 [0,0]。题目不难，主要考察边界值的处理。 一个长度小于10的字符串 全是大写字母 有重复 问重新组合后 有多少种可能的组合（限时20分钟） **算法题**，最长回文子串 输入一个数 输出 这个数的行数的杨辉三角 无线K倍删除 给你一个字符串和一个k，如果有k个连续的字符，就将其删除并把原字符串合并，一直进行到删不了为止。 示例：输入 dbbbdcccdaa 3 输出 aa 手撕代码：二分查找 然后手撕代码，二叉树相关 最近在看什么书 是否会在github上寻找一些相关项目学习，或者在stackoverflow上回答问题 对华为的了解，怎么认识华为的企业文化 。怎么看待奋斗者文化啊 ​ 华为是全球领先的信息与通信技术（ICT）解决方案供应商，专注于ICT领域，坚持稳健经营、持续创新、开放合作，在电信运营商、企业、终端和云计算等领域构筑了端到端的解决方案优势，为运营商客户、企业客户和消费者提供有竞争力的ICT解决方案、产品和服务，并致力于实现未来信息社会、构建更美好的全联接世界。 ​ 华为消费者业务产品全面覆盖手机、移动宽带终端、终端云等，凭借自身的全球化网络优势、全球化运营能力，致力于将最新的科技带给消费者，让世界各地享受到技术进步的喜悦，以行践言，实现梦想。 怎么看待华为最近遭受美国打压这一现象 问怎么看待华为的加班 讲一个自己坚持了很久的习惯、行为等 自己在某一个项目（比赛）中扮演的角色（比如是否是自己组织的） 面对这份工作你的优缺点 问了问竞赛经历 你最有成就感的事情。 你遇到困难是怎么解决的。 找最长公共子串 对排序算法有了解么，回答说快排最了解 1.面经01来源：华为数字化IT应用工程师面经 作者：MathStarry链接：https://www.nowcoder.com/discuss/618526?type=post&amp;order=time&amp;pos=&amp;page=1&amp;channel=-1&amp;source_id=search_post_nctrack来源：牛客网 3.10 机考 三道算法题 1、给定两个字符串，对第二个字符串至多改动k次，使第二个字符串为第一个字符串的子串，返回满足要求的改动方法数。 2、 第一行输入两个数字N，K，表示有N个数字以及一个整数K，第二行输入空格隔开的N个数字，要求取连续的若干个数字使得他们的和恰为K的整数倍，问有多少种取法？ 3、 有N个广播站，相连的广播站之间可以互相传递广播，给定一个邻接矩阵，相连的广播站之间矩阵值为 ‘1’，否则为 ‘0’，问最开始至少需要给几个广播站广播，才能使所有广播站都收到广播？ 3.15 一面（10:00-10:30） 5、 算法题 ，给定一个数组和目标值，求数组中满足两数之和等于目标值的下标对，若不存在满足条件的对则返回 [0,0]。题目不难，主要考察边界值的处理。 6、最近在看什么书 7、是否会在github上寻找一些相关项目学习，或者在stackoverflow上回答问题 8、对华为的了解 9、怎么看待华为最近遭受美国打压这一现象 10、为什么没有留在实习的公司 3.15 二面（11:12-11:51） 2、问实习项目，业务需求，项目如何服务与需求 4、 算法题 ，最长回文子串 3.19 三面（15:17-15:44） 2、自己在某一个项目（比赛）中扮演的角色（比如是否是自己组织的） 3、讲一个自己坚持了很久的习惯、行为等 4、对华为的了解，怎么认识华为的企业文化 ​ 2.面经02许愿华为Offer，附数字化IT应用工程师面经 作者：Poison•链接：https://www.nowcoder.com/discuss/619473?type=post&amp;order=time&amp;pos=&amp;page=1&amp;channel=-1&amp;source_id=search_post_nctrack来源：牛客网 业务应用与IT装备部——数字化IT应用工程师 3.13早上一面 不到40分钟 询问会哪些编程语言 回答Java、Pyhton、C++ 追问 他们的面向对象特点（封装、继承、多态 面试官说讲一讲自己的理解 不用背概念） 讲一讲线程 追问 线程同步机制 追问 讲一讲线程实现方式 讲一下你的项目 以及你在项目中的分工（简单介绍 没有深入问细节 讲一讲竞赛经历 询问成绩、专业排名 面试官说来华为压力大 最后的手撕代码环节 一个长度小于10的字符串 全是大写字母 有重复 问重新组合后 有多少种可能的组合（限时20分钟） 3.14早上二面 不到30分钟 自我介绍 询问Java语言的特点（封装、继承、多态，又问了抽象） 说到封装的权限修饰符又追问default不同包能不能访问 询问项目 和一面一样 介绍+分工 没有细问下去 询问竞赛经历 具体的其中一个竞赛 担任了什么角色 有没有拿过奖学金 询问成绩、专业排名 手撕代码环节 输入一个数 输出 这个数的行数的杨辉三角（面试官说非常简单 限时15分钟） 3.14下午三面 40分钟一秒不差（不愧是总监） 询问大学生活（社团有没有、社会实践有没有、科研情况） 询问成绩、专业排名 询问有没有考研 询问有没有入党（没）想不想入党（莫非是想当我的入党介绍人😧） 询问家底（生活费每月多少、父母干什么的） 看到有软著和专利又问了问具体的项目 不过不是技术细节 更多的是项目做到什么程度、用什么框架、怎么落地、用了多久、都有谁参加、你在项目中什么角色、遇到什么问题 问了问竞赛经历 问怎么看待华为的加班 介绍了岗位的工作内容（好像是对内服务部门，这块没听明白） 介绍华为技术路线和管理路线 问我想走哪条路 3.面经03作者：Citrus_2333链接：https://www.nowcoder.com/discuss/621820?type=post&amp;order=time&amp;pos=&amp;page=1&amp;channel=-1&amp;source_id=search_post_nctrack来源：牛客网 3.20 一面： 自我介绍 笔试复盘 根据用的语言问了基础问题 还问了其他的但是不会，面试官人很好还跟我讲23333 然后就手撕代码，不难枚举就行，而且面试官还给提示。但是见鬼的没调出来 = =，面试官人真的很nice，安慰我说没事思路确实是对的然后抬手给我过了。 二面： 速度贼快，说是一面问过了简单点不问了 然后项目问了一点之后就火速撕代码了，说是本科生不给难题了，真的就异常简单，python 5min就写完了 因为上面进行的太快了于是进入了反问环节，然后问了考研和工作的看法，根据这个还给我了个人的意见，又是一个非常nice的面试官 3.23 主管面 好家伙今天可能赶上主管加班了从上午等到了下午，等麻了简直 但是不得不说主管也非常和蔼可亲 就是唠嗑：项目分工啊，如果矛盾怎么办啊，想做啥方面啊，怎么看待奋斗者文化啊，去年的目标是啥，考研啥的 然后也没反问，快乐886了 但是真的今天等了一整天，真的等的我身心疲惫 4.面经04作者：牛客913569319号链接：https://www.nowcoder.com/discuss/620618?type=post&amp;order=time&amp;pos=&amp;page=1&amp;channel=-1&amp;source_id=search_post_nctrack来源：牛客网 3.24 综面 感觉有点压力面那味了，一点也没有和蔼可亲笑眯眯好不好，不苟言笑，全程我最深刻的印象就是举个例子。。举个例子。。举个例子。。 学过最难的科目，怎么学习的，举个例子 看过的算法书，有什么算法是一直贯彻在学习和工作中的，举个例子 去年最大的目标是什么，怎么实现的，做了什么，举个例子 项目小组中有没有分歧，怎么解决的，举个例子 项目中用到的具体算法，怎么理解的，举个例子 等等等等举例子。。。。。。每个问题基本都会要回归到例子来体现 如何看待华为奋斗者文化 面对这份工作你的优缺点 -—————————————————————————————————————————————————— 目前进度： 3.10笔试，3.13 性格测试 3.19 一二面 现等通知。。。 过了几天了，记性不是很好，只能记得个大概，大家有问题可以评论区找我。 笔试 笔试的题目前面已经有人发过了，我就不发了。 不过我还是想问问是我运气比较好还是华为的笔试确实不是很难。 第一题暴力字符串匹配AC 第二题暴力过70% 第三题图遍历AC 一面 聊项目相关，我的项目是手势识别目标检测。 问到了数据集和数据处理，模型，效果，具体的改进。 c++相关 python相关 static关键字 重载和重写 印象里操作系统和计网没有涉及 手撕代码：无线K倍删除 给你一个字符串和一个k，如果有k个连续的字符，就将其删除并把原字符串合并，一直进行到删不了为止。 示例：输入 dbbbdcccdaa 3 输出 aa 我用栈实现的，最后还有一点小bug，面试官还是让我过了。 二面 聊项目相关，可能面试官也是这个方向的？问的问题比较多 主流的目标检测算法，模型的选择，有没有横向对比过其他模型，有没有对比过机器学习和神经网络 项目框架大概是怎么样的，项目卡进度了怎么办，调参一直调不到想要的结果怎么办，有没有尝试多种模型实现。 你最有成就感的事情。 你遇到困难是怎么解决的。 手撕代码：二分查找 总体感觉 面试问题只记得部分了。。 首先感觉华为面试人很多，大家都在排队，面试官也很忙，每天干完活还得面试。 一面的面试官比较高冷，像是个提问机器，但是人也很好，手撕代码会提示思路，不会把你忘不会了问。 二面的面试官感觉就比较聊得来，聊了些有的没的，全程笑嘻嘻的，基本上都是项目相关。 主管面 主管面本来是约了20日18点的，后来公司打电话推迟到今天了。 先说一下面试官，我感觉面试官跟一面的长得一模一样。（一面的时候，面试官那边信号不好，把视频关了） 先自我介绍。 面试官问了我项目，项目的角色，我的成绩排名，你最紧张的一件事是什么，最有成就感的一件事，你对于成就感的定义是什么。 你的性格是怎么样的。你的最好的朋友是谁，你最讨厌的一个人是谁。你大学参加了什么活动。你有一件事情，你的计划是什么。 在大学期间你感觉你比别人努力吗。你上大学时候的目标是什么？ 反问环节： 1.华为员工的一个成长历程是怎么样的？ 面试官：首先有两周的一个文化体验，然后有导师带，六个月后转正答辩。 2.华为的部门之间有壁垒吗？ 面试官：基层这边的话，基本上是比较开放的。 最后面试官补充问了一个问题，你笔试成绩不错，是有什么诀窍吗？ 我：笔试之前，我会针对性看一些帖子，看看华为比较喜欢考什么。 然后就886。 一面 先自我介绍，然后说我在大学学了什么课，然后介绍自己参加的比赛项目。 然后面试官问了我大学成绩排名，GPI，四六级，大学参加了什么活动社团之类的。 然后就问基础了。 面试官：说一下接口和抽象类的区别。 这个问题答案大家自行网上搜。 面试官：说一下Cookie和Session有什么区别。 这里贴一下 Guide哥的面试知识点 面试官：说一下List，Set，Map的区别。 这个问题我昨晚突击看 Guide哥的Java容器只是简单看了一下，没有准确答出来。 面试官：说一下HashMap的实现。 这里 Guide哥也有，好吧，我沦为替Guide哥打广告的工具人了。 最后是代码，主要是给你一个IPv4或者IPv6地址，让你判断这个IP地址是否合法。 没完成，主要是不知道16进制的字符串怎么转换成数字，现在贴一下别人的 代码 后面面试官让我说一下思路。 面试官：你觉得你自己有什么技术上的短板吗？ 我：动态规划，因为这周以来做的笔试遇到动态规划都没做出来。 然后面试快结束了，面试官问你有什么问题想问面试官的吗？ 我：可不可以说一下你对我此次面试的看法？ 面试官一个反客为主：你对你自己这次面试有什么评价吗？ 二面 一开始自我介绍，跟一面差不多。 面试官只是简单问了一下比赛项目的事。 然后开始一些知识点提问。 面试官：数据库优化怎么做的啊？ 我：主要是答了索引。 面试官：说一下二叉树的遍历。 我：4种，第一是层序遍历，其他三种是先序遍历、中序遍历、后序遍历。 面试官：说一下后面三种遍历的思路。 面试官：说一下层序遍历具体是怎么实现的。 我：用栈（答错了，应该用队列） 面试官：说一下字符串匹配算法。 我：答了朴素的字符串匹配，然后答了KMP的思路。 面试官：说一下拓扑排序。 我：不懂。 面试官：那你会什么排序算法啊？ 我：选择排序、插入排序、快速排序、冒泡排序、堆排序、归并排序、希尔排序、桶排序、基数排序。 面试官：说一下快速排序的思路，算法复杂度 面试官：快速排序是稳定的吗？ 面试官：访问网站的时候，网站加载变慢了，怎么解决？ 我：……（支吾了一阵子），可能是网络发生拥塞，应该过一段时间再来看，或者换一个环境。 面试官：还有呢？ 我： ……查看HTTP状态码，是否是客户端或者服务器的问题…… 后来同学说是数据库搜索语句的问题，搜索语句太复杂导致数据库搜索太久了。 最后是代码，也没完成。最后说了一下思路就拜拜了。 * 你有一副手牌，手牌由大于0的整数组成。 * 游戏规则给定一个W，W为一个顺子的长度，并且顺子都是有由连续的数字组成。 * 现在他想把手牌重新排列，问是否能将手牌全部组成顺子。 * 提示： * 1 &lt;= hand.length &lt;= 10000 * 0 &lt;= hand[i] &lt;= 10^9 * 1 &lt;= W &lt;= hand.length * * 解答要求 * 时间限制：1000ms, 内存限制：256MB * * 示例 1： * 输入：hand = [1, 2, 3, 6, 2, 3, 4, 7, 8], W = 3 * 输出：true * 解释：手牌可以被重新排列为 [1,2,3]，[2,3,4]，[6,7,8]。 * * 示例 2： * 输入：hand = [1, 2, 3, 4, 5], W = 4 * 输出：false * 解释：手牌无法被重新排列成几个大小为 4 的顺子。 * * 示例 3： * 输入：hand = [1, 2, 3, 6, 7, 10], W = 3 * 输出：false * 解释：手牌能排列成长度为3的两个组[1,2,3]，[6,7,10]， 但是其中一个组不连续，不构成顺子。 5.面经05作者：道雪链接：https://www.nowcoder.com/discuss/619347?type=post&amp;order=time&amp;pos=&amp;page=1&amp;channel=-1&amp;source_id=search_post_nctrack来源：牛客网 由于签了保密协议，因此不方便透露具体问题。 3.2通过机考三道题。 三道题分别100 200 300分，网传100分就可以通过。 楼主380分，分别0.9 1 0.3。牛客内貌似可以查到3.2华为机考题目，我就不透露了。 第一题简单，但是最后一个测试用例怎么都过不了，拿了0.9. 第二题二叉树相关，思路简单，实现较为繁琐，花费时间较大，写出来了，200分，1。 第三题是寻路问题强化版，我想写个基础解法拿点分，但是时间不够，就随便暴力猜了猜答案拿了90分（0.3）。 随后经过了漫长的等待 3.19一面二面顺序进行 一面： 主要问了java相关，问的比较细，结合其他我学过的语言询问区别、以及容器、框架、源码…… （其实楼主就自学了两个周的java,答了大概70%，不会的就老老实实说不会了） 没有问操作系统，计算机网络就问了GET\\POST区别。 然后手撕代码，二叉树相关，简单题加了一丢丢难度。 写出来了，讲了思路，但是有点问题跑不出来，面试官算我过了。 一面结束5分钟后就显示通过，半小时后就二面。 二面： 只问了项目不问基础，问的十分细致。 问完直接手撕代码，机考第一题的强化班，本来高兴的要死，说这不是机考第一题么，发现是强化班垮了脸。 不过机考完我就思考了下这道题通用解法怎么写，很快想出思路给面试官讲了思路，然后处理边界条件。 本地跑了测试用例，直接给我过了。 半小时后通知二面通过。 主管面紧接着第二天下午。 面试官有点不苟言笑，不过聊的时间很长，没有问项目，更多问的是经历、看法、态度一类的。 最后面试结束说了我面试中的的一些缺点，提了建议，私人的和我聊了聊华为（主管人真的nice，面冷心善） 面试完5分钟官网显示一条绿通过，但是还没收到通过短信。 然后现在在资源池泡着吧估计。。。。等捞。 许愿offer,许愿offer. 不想再面试其他的了。 6.面经06作者：买太平湖底陈年水墨链接：https://www.nowcoder.com/discuss/602065?type=post&amp;order=time&amp;pos=&amp;page=2&amp;channel=-1&amp;source_id=search_post_nctrack来源：牛客网 面试时间 上午10点到12.30 不得不说华为效率太高了，上午接着两面完毕 一面 自我介绍 项目相关 问了很多具体业务相关的东西，这块我很多不是很懂 问了Java的classloader 算法题 二选一 找最长公共子串 树的前序遍历 选了第一个 over 二面 聊天 对排序算法有了解么，回答说快排最了解 写快排 聊天 over 二面通过，找时间约三面","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"面试准备","slug":"面试准备","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"}],"author":"learnqiu"},{"title":"C# 使用NPOI操作excel工具类","slug":"tech-excelUtil-01","date":"2021-03-22T02:40:10.000Z","updated":"2021-03-30T07:04:48.767Z","comments":true,"path":"posts/archives/8727.html/","link":"","permalink":"http://example.com/posts/archives/8727.html/","excerpt":"","text":"C# 使用NPOI操作excel工具类1.在VS中安装NPOI打开Nuget包管理器 安装NPOI 2.工具类代码using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.IO; using NPOI; using NPOI.SS.UserModel; using NPOI.XSSF.UserModel; using NPOI.HSSF.UserModel; using System.Data; using NPOI.HSSF.Util; using NPOI.SS.Util; using System.Web; namespace Nsga2ExeclPro &#123; // /// &lt;summary&gt; /// Excel操作类 /// &lt;/summary&gt; public class NPOIHelper : IDisposable &#123; private string fileALLPath = &quot;&quot;;//Excel物理路径（绝对路径） private IWorkbook workbook = null;//使用NPOI初始化的Excel工作簿 private FileStream fs = null;//Excel文件流 private bool disposed; private string rowsCode = &quot;&lt;%ROWS:&#123;0&#125;%&gt;&quot;;//数据行绑定码 public NPOIHelper() &#123; disposed = false; &#125; public NPOIHelper(string fileALLPath) &#123; this.fileALLPath = fileALLPath; disposed = false; //使用NPOI初始化的Excel工作簿 this.fs = new FileStream(fileALLPath, FileMode.Open, FileAccess.Read); if (fileALLPath.IndexOf(&quot;.xlsx&quot;) &gt; 0) &#123; workbook = new XSSFWorkbook(fs); &#125; else if (fileALLPath.IndexOf(&quot;.xls&quot;) &gt; 0) &#123; workbook = new HSSFWorkbook(fs); &#125; &#125; /// &lt;summary&gt; /// 将DataTable数据导入到excel中 /// &lt;/summary&gt; /// &lt;param name=&quot;data&quot;&gt;要导入的数据&lt;/param&gt; /// &lt;param name=&quot;isColumnWritten&quot;&gt;DataTable的列名是否要导入&lt;/param&gt; /// &lt;param name=&quot;sheetName&quot;&gt;要导入的excel的sheet的名称&lt;/param&gt; /// &lt;returns&gt;导入数据行数(包含列名那一行)&lt;/returns&gt; public int DataTableToExcel(DataTable data, string sheetName, bool isColumnWritten) &#123; int i = 0; int j = 0; int count = 0; ISheet sheet = null; fs = new FileStream(fileALLPath, FileMode.OpenOrCreate, FileAccess.ReadWrite); if (fileALLPath.IndexOf(&quot;.xlsx&quot;) &gt; 0) // 2007版本 workbook = new XSSFWorkbook(); else if (fileALLPath.IndexOf(&quot;.xls&quot;) &gt; 0) // 2003版本 workbook = new HSSFWorkbook(); try &#123; if (workbook != null) &#123; sheet = workbook.CreateSheet(sheetName); &#125; else &#123; return -1; &#125; if (isColumnWritten == true) //写入DataTable的列名 &#123; IRow row = sheet.CreateRow(0); for (j = 0; j &lt; data.Columns.Count; ++j) &#123; row.CreateCell(j).SetCellValue(data.Columns[j].ColumnName); &#125; count = 1; &#125; else &#123; count = 0; &#125; for (i = 0; i &lt; data.Rows.Count; ++i) &#123; IRow row = sheet.CreateRow(count); for (j = 0; j &lt; data.Columns.Count; ++j) &#123; row.CreateCell(j).SetCellValue(data.Rows[i][j].ToString()); &#125; ++count; &#125; workbook.Write(fs); //写入到excel return count; &#125; catch (Exception ex) &#123; Console.WriteLine(&quot;Exception: &quot; + ex.Message); return -1; &#125; &#125; /// &lt;summary&gt; /// 将excel中的数据导入到DataTable中 /// &lt;/summary&gt; /// &lt;param name=&quot;sheetName&quot;&gt;excel工作薄sheet的名称&lt;/param&gt; /// &lt;param name=&quot;isFirstRowColumn&quot;&gt;第一行是否是DataTable的列名&lt;/param&gt; /// &lt;returns&gt;返回的DataTable&lt;/returns&gt; public DataTable ExcelToDataTable(string sheetName, bool isFirstRowColumn) &#123; ISheet sheet = null; DataTable data = new DataTable(); int startRow = 0; try &#123; fs = new FileStream(fileALLPath, FileMode.Open, FileAccess.Read); if (fileALLPath.IndexOf(&quot;.xlsx&quot;) &gt; 0) // 2007版本 workbook = new XSSFWorkbook(fs); else if (fileALLPath.IndexOf(&quot;.xls&quot;) &gt; 0) // 2003版本 workbook = new HSSFWorkbook(fs); if (sheetName != null) &#123; sheet = workbook.GetSheet(sheetName); if (sheet == null) //如果没有找到指定的sheetName对应的sheet，则尝试获取第一个sheet &#123; sheet = workbook.GetSheetAt(0); &#125; &#125; else &#123; sheet = workbook.GetSheetAt(0); &#125; if (sheet != null) &#123; IRow firstRow = sheet.GetRow(0); int cellCount = firstRow.LastCellNum; //一行最后一个cell的编号 即总的列数 if (isFirstRowColumn) &#123; for (int i = firstRow.FirstCellNum; i &lt; cellCount; ++i) &#123; ICell cell = firstRow.GetCell(i); if (cell != null) &#123; cell.SetCellType(CellType.String);//设置为String string cellValue = cell.StringCellValue; if (cellValue != null) &#123; DataColumn column = new DataColumn(cellValue); data.Columns.Add(column); &#125; &#125; &#125; startRow = sheet.FirstRowNum + 1; &#125; else &#123; startRow = sheet.FirstRowNum; &#125; //最后一列的标号 int rowCount = sheet.LastRowNum; for (int i = startRow; i &lt;= rowCount; ++i) &#123; IRow row = sheet.GetRow(i); if (row == null) continue; //没有数据的行默认是null DataRow dataRow = data.NewRow(); for (int j = row.FirstCellNum; j &lt; cellCount; ++j) &#123; if (row.GetCell(j) != null) //同理，没有数据的单元格都默认是null dataRow[j] = row.GetCell(j).ToString(); &#125; data.Rows.Add(dataRow); &#125; &#125; return data; &#125; catch (Exception ex) &#123; Console.WriteLine(&quot;Exception: &quot; + ex.Message); return null; &#125; &#125; /// &lt;summary&gt; /// 获取Excel中Sheet名称集合 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public string[] SheetNames() &#123; fs = new FileStream(fileALLPath, FileMode.Open, FileAccess.Read); if (fileALLPath.IndexOf(&quot;.xlsx&quot;) &gt; 0) // 2007版本 workbook = new XSSFWorkbook(fs); else if (fileALLPath.IndexOf(&quot;.xls&quot;) &gt; 0) // 2003版本 workbook = new HSSFWorkbook(fs); int sheetCount = workbook.NumberOfSheets; string[] sheetName = new string[sheetCount];//保存表的名称 for (int i = 0; i &lt; sheetCount; i++) &#123; sheetName[i] = workbook.GetSheetName(i); &#125; return sheetName; &#125; /// &lt;summary&gt; /// 删除指定的Sheets /// &lt;/summary&gt; public void RemoveSheetsByNames(string[] sheetNames) &#123; foreach (string sheetName in sheetNames) &#123; ISheet sheet = workbook.GetSheet(sheetName); int index = workbook.GetSheetIndex(sheet); workbook.RemoveSheetAt(index); &#125; &#125; /// &lt;summary&gt; /// 保存修改后的excel /// &lt;/summary&gt; public void Save() &#123; FileStream fileSave = new FileStream(fileALLPath, FileMode.Open, FileAccess.Write); workbook.Write(fileSave); fileSave.Close(); &#125; /// &lt;summary&gt; /// 填充Sheet /// &lt;/summary&gt; /// &lt;param name=&quot;sheetName&quot;&gt;sheet名称&lt;/param&gt; /// &lt;param name=&quot;dt&quot;&gt;数据源（DataTable）&lt;/param&gt; /// &lt;param name=&quot;isList&quot;&gt;填充类型：&quot;对象&quot;还是&quot;集合&quot;,true:&quot;集合&quot;,false:&quot;对象&quot;&lt;/param&gt; /// &lt;param name=&quot;dtName&quot;&gt;DataTable TableName&lt;/param&gt; /// &lt;param name=&quot;isAlarm&quot;&gt;是否是：业务风险提示&lt;/param&gt; /// &lt;param name=&quot;rowIndex&quot;&gt;遍历Excel范围：行数，默认30行&lt;/param&gt; /// &lt;param name=&quot;colIndex&quot;&gt;遍历Excel范围：列数，默认20列&lt;/param&gt; public void FillSheet(string sheetName, DataTable dt, bool isList, string dtName = &quot;&quot;, bool isAlarm = false, int rowIndex = 30, int colIndex = 20) &#123; if (dt == null || dt.Rows.Count &lt;= 0) return; ISheet sheet = workbook.GetSheet(sheetName); if (sheet == null) return; if (!isList) &#123; //&quot;对象填充&quot; foreach (DataColumn column in dt.Columns) &#123; for (int rowIn = 0; rowIn &lt; rowIndex; rowIn++) &#123; for (int colIn = 0; colIn &lt; colIndex; colIn++) &#123; IRow row = sheet.GetRow(rowIn); if (row == null) continue; ICell cell = row.GetCell(colIn); if (cell == null) continue; if (string.IsNullOrEmpty(dtName)) &#123; dtName = dt.TableName; &#125; string a = string.Empty; if (isAlarm) &#123; a = &quot;$&quot; + column.ColumnName; &#125; else &#123; a = &quot;&lt;%&quot; + dtName + &quot;;&quot; + column.ColumnName + &quot;%&gt;&quot;; &#125; if (cell.ToString() == a) &#123; var value = dt.Rows[0][column.ColumnName]; if (value == DBNull.Value || value == null) &#123; cell.SetCellValue(string.Empty); &#125; else &#123; if (column.DataType.FullName == &quot;System.DateTime&quot;) &#123; cell.SetCellValue(Convert.ToDateTime(value).ToString(&quot;yyyy-MM-dd&quot;)); &#125; else if (column.DataType.FullName == &quot;System.Decimal&quot;) &#123; cell.SetCellValue(double.Parse(Convert.ToDecimal(value).ToString(&quot;N2&quot;))); &#125; else &#123; cell.SetCellValue(value.ToString()); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; //&quot;集合&quot;填充 ICellStyle style = workbook.CreateCellStyle(); style.BorderBottom = BorderStyle.Thin; style.BorderLeft = BorderStyle.Thin; style.BorderRight = BorderStyle.Thin; style.BorderTop = BorderStyle.Thin; for (int i = 0; i &lt; dt.Rows.Count; i++) &#123; IRow row = sheet.CreateRow(i + 1); for (int j = 0; j &lt; dt.Columns.Count; j++) &#123; ICell cell = row.CreateCell(j); cell.SetCellValue(dt.Rows[i][j].ToString()); cell.CellStyle = style; &#125; &#125; &#125; sheet.ForceFormulaRecalculation = true;//刷新单元格公式，自动计算 &#125; /// &lt;summary&gt; /// 填充Sheet数据（对多Table数据填充） /// &lt;/summary&gt; /// &lt;param name=&quot;sheetName&quot;&gt;sheet名称&lt;/param&gt; /// &lt;param name=&quot;tableNum&quot;&gt;table个数&lt;/param&gt; /// &lt;param name=&quot;tableNames&quot;&gt;table的表名（用于匹配数据源中的table和数据模板中数据绑定码&lt;/param&gt; /// &lt;param name=&quot;cellKeys&quot;&gt;table的数据列名（用于匹配数据源中对应列数据），如：&#123;&#123;\"fieldName1,fliedName2\"&#125;,&#123;\"fieldName1,fieldName2,fieldName3\"&#125;&#125;,字段名之间使用 , 分割&lt;/param&gt; /// &lt;param name=&quot;dts&quot;&gt;数据源&lt;/param&gt; /// &lt;param name=&quot;cellCount&quot;&gt;数据列数，默认为0，取第一行的数据列数&lt;/param&gt; /// &lt;param name=&quot;isSum&quot;&gt;是否求和，默认不求和。如果为true，会搜索“合计”行，把数据类型为decimal的列求和&lt;/param&gt; public void FillSheetEx(string sheetName, int tableNum, string[] tableNames, string[] cellKeys, DataSet dts, int cellCount = 0, bool isSum = false) &#123; if (dts == null || dts.Tables.Count &lt;= 0) &#123; return; &#125; ISheet sheet = workbook.GetSheet(sheetName); if (sheet == null) &#123; return; &#125; if (sheet != null) &#123; if (cellCount == 0) &#123; cellCount = sheet.GetRow(0).LastCellNum;//列数 &#125; int searchRow = 0;//搜索开始行 int startRow = 0; int startCell = 0; string content = &quot;&quot;; for (int i = 0; i &lt; tableNum; i++) &#123; content = string.Format(rowsCode, tableNames[i]);//数据绑定码 MatchSheetContent(sheet, content, out startRow, out startCell, cellCount, 5, searchRow);//获取插入数据的行和列 if (startRow &gt; 0) &#123; sheet.GetRow(startRow).GetCell(startCell).SetCellValue(&quot;&quot;);//清空数据绑定码信息 InsertSheetData(sheet, dts.Tables[tableNames[i]], startRow, dts.Tables[tableNames[i]].Columns.Count, cellKeys[i].Split(&#39;,&#39;), isSum);//插入数据 searchRow = startRow + dts.Tables[tableNames[i]].Rows.Count + 3; //3：表和表之间隔2行 if (isSum) &#123; searchRow = searchRow + 1;//合计的1行 &#125; &#125; else &#123; continue; &#125; &#125; &#125; sheet.ForceFormulaRecalculation = true;//刷新单元格公式，自动计算 &#125; /// &lt;summary&gt; /// 下载Excel /// &lt;/summary&gt; /// &lt;param name=&quot;fileName&quot;&gt;下载时，显示的文件名&lt;/param&gt; public void Download(string fileName) &#123; FileStream fs = new FileStream(fileName, FileMode.Open); byte[] bytes = new byte[(int)fs.Length]; fs.Read(bytes, 0, bytes.Length); fs.Close(); System.Web.HttpContext.Current.Response.ContentType = &quot;application/octet-stream;charset=gb2312&quot;; System.Web.HttpContext.Current.Response.AddHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + System.Web.HttpUtility.UrlEncode(fileName, System.Text.Encoding.UTF8)); System.Web.HttpContext.Current.Response.BinaryWrite(bytes); System.Web.HttpContext.Current.Response.Flush(); System.Web.HttpContext.Current.ApplicationInstance.CompleteRequest(); &#125; /// &lt;summary&gt; /// 直接下载Excel文件 /// &lt;/summary&gt; /// &lt;param name=&quot;fileName&quot;&gt;&lt;/param&gt; public void DownloadEx(string fileName) &#123; int length = (int)fs.Length; byte[] data = new byte[length]; fs.Position = 0; fs.Read(data, 0, length); fs.Close(); byte[] buffer; using (MemoryStream ms = new MemoryStream(data)) &#123; buffer = new byte[ms.Capacity]; if (ms.CanRead) &#123; ms.Read(buffer, 0, ms.Capacity); &#125; &#125; System.Web.HttpContext.Current.Response.Clear(); System.Web.HttpContext.Current.Response.ContentType = &quot;application/octet-stream;charset=gb2312&quot;; System.Web.HttpContext.Current.Response.AddHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + System.Web.HttpUtility.UrlEncode(fileName, System.Text.Encoding.UTF8)); System.Web.HttpContext.Current.Response.BinaryWrite(buffer); System.Web.HttpContext.Current.Response.Flush(); System.Web.HttpContext.Current.ApplicationInstance.CompleteRequest(); &#125; public void Dispose() &#123; Dispose(true); GC.SuppressFinalize(this); &#125; protected virtual void Dispose(bool disposing) &#123; if (!this.disposed) &#123; if (disposing) &#123; if (fs != null) fs.Close(); &#125; fs = null; disposed = true; &#125; &#125; #region 其他成员方法 /// &lt;summary&gt; /// 在sheet中的某个单元格设置计算函数（会导致Excel文件错误，方法待优化） /// &lt;/summary&gt; /// &lt;param name=&quot;sheetName&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;rowIndex&quot;&gt;设置单元格行索引&lt;/param&gt; /// &lt;param name=&quot;cellIndex&quot;&gt;设置单元格列索引&lt;/param&gt; /// &lt;param name=&quot;operatorCode&quot;&gt;函数名&lt;/param&gt; /// &lt;param name=&quot;startRowIndex&quot;&gt;开始行索引&lt;/param&gt; /// &lt;param name=&quot;startCellIndex&quot;&gt;开始列索引&lt;/param&gt; /// &lt;param name=&quot;endRowIndex&quot;&gt;结束行索引&lt;/param&gt; /// &lt;param name=&quot;endCellIndex&quot;&gt;结束列索引&lt;/param&gt; /// &lt;param name=&quot;dataFormat&quot;&gt;默认：194：数值格式&lt;/param&gt; public void OperatorFormula(string sheetName, int rowIndex, int cellIndex, string operatorCode, int startRowIndex, int startCellIndex, int endRowIndex, int endCellIndex, short dataFormat = 194) &#123; ISheet sheet = workbook.GetSheet(sheetName); if (sheet == null) &#123; return; &#125; string strFormula = GetOperatorFormula(operatorCode, startRowIndex, startCellIndex, endRowIndex, endCellIndex); ICell cell = sheet.GetRow(rowIndex).GetCell(cellIndex); cell.CellStyle.DataFormat = dataFormat; cell.SetCellType(CellType.Formula); cell.SetCellFormula(strFormula); &#125; #endregion #region 扩展方法 /// &lt;summary&gt; /// 下载服务器文件 /// &lt;/summary&gt; /// &lt;param name=&quot;fileAllPath&quot;&gt;文件全路径&lt;/param&gt; /// &lt;param name=&quot;fileName&quot;&gt;下载文件名（包含扩展名）&lt;/param&gt; public static void Download(string fileAllPath, string fileName) &#123; if (!File.Exists(fileAllPath)) &#123; return; &#125; using (FileStream fs = new FileStream(fileAllPath, FileMode.Open)) &#123; byte[] buffer = new byte[(int)fs.Length]; fs.Read(buffer, 0, buffer.Length); fs.Close(); HttpContext.Current.Response.Clear(); HttpContext.Current.Response.ContentType = &quot;application/octet-stream;charset=gb2312&quot;; HttpContext.Current.Response.AddHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + System.Web.HttpUtility.UrlEncode(fileName, System.Text.Encoding.UTF8)); HttpContext.Current.Response.BinaryWrite(buffer); HttpContext.Current.Response.Flush(); HttpContext.Current.ApplicationInstance.CompleteRequest(); &#125; &#125; /// &lt;summary&gt; /// 下载数据文件 /// &lt;/summary&gt; /// &lt;param name=&quot;workbook&quot;&gt;Excel实体&lt;/param&gt; /// &lt;param name=&quot;fileName&quot;&gt;下载文件名（包含扩展名）&lt;/param&gt; public static void Download(HSSFWorkbook workbook, string fileName) &#123; using (MemoryStream ms = new MemoryStream()) &#123; workbook.Write(ms); ms.Flush(); ms.Position = 0; byte[] buffer = new byte[ms.Capacity]; if (ms.CanRead) &#123; ms.Read(buffer, 0, ms.Capacity); &#125; ms.Close(); HttpContext.Current.Response.Clear(); HttpContext.Current.Response.ContentType = &quot;application/octet-stream;charset=gb2312&quot;; HttpContext.Current.Response.AddHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + HttpUtility.UrlEncode(fileName, Encoding.UTF8)); HttpContext.Current.Response.BinaryWrite(buffer); HttpContext.Current.Response.Flush(); HttpContext.Current.ApplicationInstance.CompleteRequest(); &#125; &#125; /// &lt;summary&gt; /// 创建单元格样式 /// &lt;/summary&gt; /// &lt;param name=&quot;workbook&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;type&quot;&gt;单元格类型&lt;/param&gt; /// &lt;param name=&quot;fontHeightInPoints&quot;&gt;字号，传0为默认字号&lt;/param&gt; /// &lt;param name=&quot;foregroundColor&quot;&gt;背景色（可通过NPOI.HSSF.Util.HSSFColor获取色值）&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static ICellStyle CreateCellStyle(HSSFWorkbook workbook, SheetCellType type, short fontHeightInPoints = 0, short foregroundColor = 0) &#123; ICellStyle cellStyle = workbook.CreateCellStyle(); switch (type.ToString()) &#123; case &quot;CellTitle&quot;: #region 标题样式 //设置单元格边框 cellStyle.BorderBottom = NPOI.SS.UserModel.BorderStyle.Thin; cellStyle.BorderLeft = NPOI.SS.UserModel.BorderStyle.Thin; cellStyle.BorderRight = NPOI.SS.UserModel.BorderStyle.Thin; cellStyle.BorderTop = NPOI.SS.UserModel.BorderStyle.Thin; //设置单元格边框颜色 cellStyle.BottomBorderColor = HSSFColor.Black.Index; cellStyle.LeftBorderColor = HSSFColor.Black.Index; cellStyle.RightBorderColor = HSSFColor.Black.Index; cellStyle.TopBorderColor = HSSFColor.Black.Index; //设置水平垂直居中 cellStyle.VerticalAlignment = VerticalAlignment.Center; cellStyle.Alignment = HorizontalAlignment.Center; //设置单元格背景颜色 if (foregroundColor &gt; 0) &#123; cellStyle.FillForegroundColor = foregroundColor; cellStyle.FillPattern = FillPattern.SolidForeground;//填充背景样式 &#125; //新建一个字体样式对象 IFont titleFont = workbook.CreateFont(); //字体大小13.5pt,对应像素18px titleFont.FontHeightInPoints = 16; //设置字体加粗样式 titleFont.Boldweight = short.MaxValue; //使用SetFont方法将字体样式添加到单元格样式中 cellStyle.SetFont(titleFont); #endregion break; case &quot;CellField&quot;: #region 字段名样式 //设置单元格边框 cellStyle.BorderBottom = NPOI.SS.UserModel.BorderStyle.Thin; cellStyle.BorderLeft = NPOI.SS.UserModel.BorderStyle.Thin; cellStyle.BorderRight = NPOI.SS.UserModel.BorderStyle.Thin; cellStyle.BorderTop = NPOI.SS.UserModel.BorderStyle.Thin; //设置单元格边框颜色 cellStyle.BottomBorderColor = HSSFColor.Black.Index; cellStyle.LeftBorderColor = HSSFColor.Black.Index; cellStyle.RightBorderColor = HSSFColor.Black.Index; cellStyle.TopBorderColor = HSSFColor.Black.Index; //设置垂直水平居中 cellStyle.VerticalAlignment = VerticalAlignment.Center; cellStyle.Alignment = HorizontalAlignment.Center; //设置单元格背景颜色 if (foregroundColor &gt; 0) &#123; cellStyle.FillForegroundColor = foregroundColor; cellStyle.FillPattern = FillPattern.SolidForeground;//填充背景样式 &#125; IFont FiledFont = workbook.CreateFont(); //字体大小10.5pt,对应像素14px FiledFont.FontHeightInPoints = fontHeightInPoints &lt;= 0 ? (short)10 : fontHeightInPoints; //设置字体加粗样式 FiledFont.Boldweight = short.MaxValue; cellStyle.SetFont(FiledFont); #endregion break; case &quot;CellValue&quot;: #region 数据值样式 //设置单元格边框 cellStyle.BorderBottom = NPOI.SS.UserModel.BorderStyle.Thin; cellStyle.BorderLeft = NPOI.SS.UserModel.BorderStyle.Thin; cellStyle.BorderRight = NPOI.SS.UserModel.BorderStyle.Thin; cellStyle.BorderTop = NPOI.SS.UserModel.BorderStyle.Thin; //设置单元格边框颜色 cellStyle.BottomBorderColor = HSSFColor.Black.Index; cellStyle.LeftBorderColor = HSSFColor.Black.Index; cellStyle.RightBorderColor = HSSFColor.Black.Index; cellStyle.TopBorderColor = HSSFColor.Black.Index; //设置垂直水平居中 cellStyle.VerticalAlignment = VerticalAlignment.Center; cellStyle.Alignment = HorizontalAlignment.Center; //设置单元格背景颜色 if (foregroundColor &gt; 0) &#123; cellStyle.FillForegroundColor = foregroundColor; cellStyle.FillPattern = FillPattern.SolidForeground;//填充背景样式 &#125; IFont valueFont = workbook.CreateFont(); //字体大小10.5pt,对应像素14px valueFont.FontHeightInPoints = fontHeightInPoints &lt;= 0 ? (short)9 : fontHeightInPoints; cellStyle.SetFont(valueFont); #endregion break; &#125; return cellStyle; &#125; /// &lt;summary&gt; /// 合并及填充单元格 /// &lt;/summary&gt; /// &lt;param name=&quot;sheet&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;firstRow&quot;&gt;第一行的index&lt;/param&gt; /// &lt;param name=&quot;lastRow&quot;&gt;最后一行的index&lt;/param&gt; /// &lt;param name=&quot;firstCol&quot;&gt;第一列的index&lt;/param&gt; /// &lt;param name=&quot;lastCol&quot;&gt;最后一列的index&lt;/param&gt; /// &lt;param name=&quot;content&quot;&gt;填充内容&lt;/param&gt; /// &lt;param name=&quot;cellHeight&quot;&gt;单元格行高,默认高设置为0（标题一般传值：23.5f）&lt;/param&gt; /// &lt;param name=&quot;cellStyle&quot;&gt;单元格样式接口实例&lt;/param&gt; public static void MergeCell(HSSFSheet sheet, int firstRow, int lastRow, int firstCol, int lastCol, string content = &quot;&quot;, float cellHeight = 0, ICellStyle cellStyle = null) &#123; CellRangeAddress cellRange = new CellRangeAddress(firstRow, lastRow, firstCol, lastCol); sheet.AddMergedRegion(cellRange); //填充内容 if (!string.IsNullOrWhiteSpace(content)) &#123; IRow row = sheet.CreateRow(firstRow); row.CreateCell(firstCol).SetCellValue(content); //对应高度30px if (cellHeight &gt; 0) &#123; row.Height = (short)(cellHeight * 20); &#125; &#125; //合并单元格的样式 for (int i = cellRange.FirstRow; i &lt;= cellRange.LastRow; i++) &#123; IRow row = HSSFCellUtil.GetRow(i, sheet); for (int j = cellRange.FirstColumn; j &lt;= cellRange.LastColumn; j++) &#123; ICell singleCell = HSSFCellUtil.GetCell(row, (short)j); if (cellStyle != null) &#123; singleCell.CellStyle = cellStyle; &#125; &#125; &#125; &#125; /// &lt;summary&gt; /// 设置表格自适应宽度 /// &lt;/summary&gt; /// &lt;param name=&quot;sheet&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;cellNum&quot;&gt;表格列数&lt;/param&gt; /// &lt;param name=&quot;multiple&quot;&gt;单元格显示宽度倍数（如1.5：是内容宽度的1.5倍）,默认和内容宽度一致&lt;/param&gt; /// &lt;param name=&quot;defaultLen&quot;&gt;数据为空时，单元格的默认填充长度：2&lt;/param&gt; public static void SetAdaptiveWidth(HSSFSheet sheet, int cellNum, double multiple = 1, int defaultLen = 2) &#123; int width = defaultLen * 1024;//空数据指定宽度 int times = Convert.ToInt32(multiple * 10); for (int i = 0; i &lt;= cellNum; i++) &#123; sheet.AutoSizeColumn(i); if (sheet.GetColumnWidth(i) &gt;= 2048) &#123; width = sheet.GetColumnWidth(i); &#125; sheet.SetColumnWidth(i, width * times / 10); &#125; &#125; #endregion #region 私有方法 /// &lt;summary&gt; /// 向Sheet的指定行中插入数据 /// &lt;/summary&gt; /// &lt;param name=&quot;sheet&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;dt&quot;&gt;数据源&lt;/param&gt; /// &lt;param name=&quot;startRowIndex&quot;&gt;开始插入数据的行索引&lt;/param&gt; /// &lt;param name=&quot;cellCount&quot;&gt;数据列数&lt;/param&gt; /// &lt;param name=&quot;cellKeys&quot;&gt;列匹配关键字&lt;/param&gt; /// &lt;param name=&quot;isSum&quot;&gt;是否求和，默认不求和。如果为true，会搜索“合计”行，把数据类型为decimal的列求和&lt;/param&gt; private void InsertSheetData(ISheet sheet, DataTable dt, int startRowIndex, int cellCount, string[] cellKeys, bool isSum = false) &#123; int firstDataRow = startRowIndex; sheet.ShiftRows(startRowIndex, sheet.LastRowNum, dt.Rows.Count - 1, true, false); string dataType = &quot;&quot;; IRow row; for (int i = 0, len = dt.Rows.Count; i &lt; len; i++) &#123; row = sheet.CreateRow(startRowIndex); //创建列并插入数据 for (int index = 0; index &lt; cellCount; index++) &#123; ICellStyle cellStyle = sheet.GetRow(startRowIndex - 1).GetCell(i).CellStyle;//获取上一行的数据格式 dataType = dt.Rows[i][cellKeys[index]].GetType().ToString(); if (dataType == &quot;System.DBNull&quot;) &#123; row.CreateCell(index).SetCellValue(&quot;&quot;); &#125; else if (dataType == &quot;System.Decimal&quot;) &#123; row.CreateCell(index).SetCellValue(double.Parse(Convert.ToDecimal(dt.Rows[i][cellKeys[index]]).ToString(&quot;N2&quot;))); &#125; else if (dataType == &quot;System.DateTime&quot;) &#123; row.CreateCell(index).SetCellValue(Convert.ToDateTime(dt.Rows[i][cellKeys[index]]).ToString(&quot;yyyy-MM-dd&quot;)); &#125; else &#123; row.CreateCell(index).SetCellValue(!(dt.Rows[i][cellKeys[index]] is DBNull) ? dt.Rows[i][cellKeys[index]].ToString() : string.Empty); &#125; row.GetCell(index).CellStyle = cellStyle; &#125; startRowIndex = startRowIndex + 1; &#125; if (isSum)//求和 &#123; int startRow = 0; int startCell = 0; MatchSheetContent(sheet, &quot;合计&quot;, out startRow, out startCell, cellCount, 5, startRowIndex); if (startRow &gt; 0) &#123; IRow sumRow = sheet.GetRow(startRow); for (int index = 0; index &lt; dt.Columns.Count; index++) &#123; if (sumRow.GetCell(index).CellType == CellType.Formula)//格式为表达式，求和 &#123; sumRow.GetCell(index).SetCellFormula(GetOperatorFormula(&quot;SUM&quot;, firstDataRow, index, startRow - 1, index)); &#125; &#125; &#125; &#125; &#125; /// &lt;summary&gt; /// 获取Excel简单操作函数 /// &lt;/summary&gt; /// &lt;param name=&quot;operatorCode&quot;&gt;函数名，如：SUM&lt;/param&gt; /// &lt;param name=&quot;startRowIndex&quot;&gt;开始行索引&lt;/param&gt; /// &lt;param name=&quot;startCellIndex&quot;&gt;开始列索引&lt;/param&gt; /// &lt;param name=&quot;endRowIndex&quot;&gt;结束行索引&lt;/param&gt; /// &lt;param name=&quot;endCellIndex&quot;&gt;结束列索引&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private string GetOperatorFormula(string operatorCode, int startRowIndex, int startCellIndex, int endRowIndex, int endCellIndex) &#123; string[,] code = &#123; &#123; &quot;A&quot; &#125;, &#123; &quot;B&quot; &#125;, &#123; &quot;C&quot; &#125;, &#123; &quot;D&quot; &#125;, &#123; &quot;E&quot; &#125;, &#123; &quot;F&quot; &#125;, &#123; &quot;G&quot; &#125;, &#123; &quot;H&quot; &#125;, &#123; &quot;I&quot; &#125;, &#123; &quot;J&quot; &#125;, &#123; &quot;K&quot; &#125;, &#123; &quot;L&quot; &#125;, &#123; &quot;M&quot; &#125;, &#123; &quot;N&quot; &#125;, &#123; &quot;O&quot; &#125;, &#123; &quot;P&quot; &#125;, &#123; &quot;Q&quot; &#125;, &#123; &quot;R&quot; &#125;, &#123; &quot;S&quot; &#125;, &#123; &quot;T&quot; &#125;, &#123; &quot;U&quot; &#125;, &#123; &quot;V&quot; &#125;, &#123; &quot;W&quot; &#125;, &#123; &quot;X&quot; &#125;, &#123; &quot;Y&quot; &#125;, &#123; &quot;Z&quot; &#125; &#125;; string start = string.Format(&quot;&#123;0&#125;&#123;1&#125;&quot;, code[startCellIndex, 0], startRowIndex + 1); string end = string.Format(&quot;&#123;0&#125;&#123;1&#125;&quot;, code[endCellIndex, 0], endRowIndex + 1); return string.Format(&quot;&#123;0&#125;(&#123;1&#125;:&#123;2&#125;)&quot;, operatorCode, start, end); &#125; /// &lt;summary&gt; /// 搜索Sheet中匹配信息的单元格所在行和列 /// &lt;/summary&gt; /// &lt;param name=&quot;sheet&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;matchContent&quot;&gt;匹配信息&lt;/param&gt; /// &lt;param name=&quot;whichRow&quot;&gt;返回信息：哪一行&lt;/param&gt; /// &lt;param name=&quot;whichCell&quot;&gt;返回信息：哪一列&lt;/param&gt; /// &lt;param name=&quot;searchCells&quot;&gt;搜索Sheet表格宽度，为0时默认取第一行的宽度&lt;/param&gt; /// &lt;param name=&quot;searchRows&quot;&gt;搜索的行数，默认搜索5行&lt;/param&gt; /// &lt;param name=&quot;formWhichRow&quot;&gt;从第几行开始搜索，默认从第一行&lt;/param&gt; private void MatchSheetContent(ISheet sheet, string matchContent, out int whichRow, out int whichCell, int searchCells = 0, int searchRows = 5, int formWhichRow = 0) &#123; whichRow = -1; whichCell = -1; IRow firstRow = sheet.GetRow(0); if (searchCells == 0) &#123; searchCells = firstRow.LastCellNum;//一行最后一个cell的编号 即总的列数 &#125; //遍历Sheet,找到需要填充数据源的行位置 IRow currentRow; ICell currentCell; bool isFinish = false; for (int i = formWhichRow; i &lt; formWhichRow + searchRows; i++) &#123; currentRow = sheet.GetRow(i); for (int j = firstRow.FirstCellNum; j &lt; searchCells; j++) &#123; currentCell = currentRow.GetCell(j); if (currentCell != null &amp;&amp; currentCell.CellType == CellType.String)//仅检测字符串类型的单元格 &#123; string cellValue = currentCell.StringCellValue; if (cellValue == matchContent)//找到需要填充数据的行 &#123; whichCell = currentCell.ColumnIndex; whichRow = currentCell.RowIndex; isFinish = true; break; &#125; &#125; &#125; if (isFinish) &#123; break; &#125; &#125; &#125; #endregion &#125; /// &lt;summary&gt; /// 单元格类型 /// &lt;/summary&gt; public enum SheetCellType &#123; /// &lt;summary&gt; /// 标题 /// &lt;/summary&gt; CellTitle, /// &lt;summary&gt; /// 字段名 /// &lt;/summary&gt; CellField, /// &lt;summary&gt; /// 数据值 /// &lt;/summary&gt; CellValue &#125; &#125; 本文转载自 NPOI封装类","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"NPOI","slug":"NPOI","permalink":"http://example.com/tags/NPOI/"},{"name":"excel工具类","slug":"excel工具类","permalink":"http://example.com/tags/excel%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"author":"learnqiu"},{"title":"C#文件操作类","slug":"tech-fileUtil-01","date":"2021-03-22T02:39:53.000Z","updated":"2021-03-30T07:04:48.752Z","comments":true,"path":"posts/archives/9820.html/","link":"","permalink":"http://example.com/posts/archives/9820.html/","excerpt":"","text":"C#常用文件操作类实现代码如下： using System; using System.Text; using System.Web; using System.IO; namespace Nsga2ExeclPro &#123; /// &lt;summary&gt; /// 文件操作类 /// &lt;/summary&gt; public class FileOperate &#123; #region 写文件 public void Write_Txt(string FileName, string Content,string suffix = &quot;.txt&quot;) &#123; Encoding code = Encoding.GetEncoding(&quot;gb2312&quot;); //string htmlfilename = HttpContext.Current.Server.MapPath(&quot;Precious\\\\&quot; + FileName + suffix); //保存文件的路径 string htmlfilename = MapPath(&quot;Precious\\\\&quot; + FileName + suffix); //保存文件的路径 string str = Content; StreamWriter sw = null; &#123; try &#123; sw = new StreamWriter(htmlfilename, false, code); sw.Write(str); sw.Flush(); &#125; catch &#123; &#125; &#125; sw.Close(); sw.Dispose(); &#125; #endregion #region 读文件 public string Read_Txt(string filename) &#123; Encoding code = Encoding.GetEncoding(&quot;gb2312&quot;); string temp = HttpContext.Current.Server.MapPath(&quot;Precious\\\\&quot; + filename + &quot;.txt&quot;); string str = &quot;&quot;; if (File.Exists(temp)) &#123; StreamReader sr = null; try &#123; sr = new StreamReader(temp, code); str = sr.ReadToEnd(); // 读取文件 &#125; catch &#123; &#125; sr.Close(); sr.Dispose(); &#125; else &#123; str = &quot;&quot;; &#125; return str; &#125; #endregion /// &lt;summary&gt; /// 获取文件路径 /// &lt;/summary&gt; /// &lt;param name=&quot;strPath&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private string MapPath(string strPath) &#123; if (HttpContext.Current != null) &#123; return HttpContext.Current.Server.MapPath(strPath); &#125; else //非web程序引用 &#123; strPath = strPath.Replace(&quot;/&quot;, &quot;\\\\&quot;); if (strPath.StartsWith(&quot;\\\\&quot;)) &#123; strPath = strPath.TrimStart(&#39;\\\\&#39;); &#125; return System.IO.Path.Combine(AppDomain.CurrentDomain.BaseDirectory, strPath); &#125; &#125; #region 取得文件后缀名 /**************************************** * 函数名称：GetPostfixStr * 功能说明：取得文件后缀名 * 参 数：filename:文件名称 * 调用示列： * string filename = &quot;aaa.aspx&quot;; * string s = DotNet.Utilities.FileOperate.GetPostfixStr(filename); *****************************************/ /// &lt;summary&gt; /// 取后缀名 /// &lt;/summary&gt; /// &lt;param name=&quot;filename&quot;&gt;文件名&lt;/param&gt; /// &lt;returns&gt;.gif|.html格式&lt;/returns&gt; public static string GetPostfixStr(string filename) &#123; int start = filename.LastIndexOf(&quot;.&quot;); int length = filename.Length; string postfix = filename.Substring(start, length - start); return postfix; &#125; #endregion #region 写文件 /**************************************** * 函数名称：WriteFile * 功能说明：当文件不存时，则创建文件，并追加文件 * 参 数：Path:文件路径,Strings:文本内容 * 调用示列： * string Path = Server.MapPath(&quot;Default2.aspx&quot;); * string Strings = &quot;这是我写的内容啊&quot;; * DotNet.Utilities.FileOperate.WriteFile(Path,Strings); *****************************************/ /// &lt;summary&gt; /// 写文件 /// &lt;/summary&gt; /// &lt;param name=&quot;Path&quot;&gt;文件路径&lt;/param&gt; /// &lt;param name=&quot;Strings&quot;&gt;文件内容&lt;/param&gt; public static void WriteFile(string Path, string Strings) &#123; if (!System.IO.File.Exists(Path)) &#123; System.IO.FileStream f = System.IO.File.Create(Path); f.Close(); f.Dispose(); &#125; System.IO.StreamWriter f2 = new System.IO.StreamWriter(Path, true, System.Text.Encoding.UTF8); f2.WriteLine(Strings); f2.Close(); f2.Dispose(); &#125; #endregion #region 读文件 /**************************************** * 函数名称：ReadFile * 功能说明：读取文本内容 * 参 数：Path:文件路径 * 调用示列： * string Path = Server.MapPath(&quot;Default2.aspx&quot;); * string s = DotNet.Utilities.FileOperate.ReadFile(Path); *****************************************/ /// &lt;summary&gt; /// 读文件 /// &lt;/summary&gt; /// &lt;param name=&quot;Path&quot;&gt;文件路径&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string ReadFile(string Path) &#123; string s = &quot;&quot;; if (!System.IO.File.Exists(Path)) s = &quot;不存在相应的目录&quot;; else &#123; StreamReader f2 = new StreamReader(Path, System.Text.Encoding.GetEncoding(&quot;gb2312&quot;)); s = f2.ReadToEnd(); f2.Close(); f2.Dispose(); &#125; return s; &#125; #endregion #region 追加文件 /**************************************** * 函数名称：FileAdd * 功能说明：追加文件内容 * 参 数：Path:文件路径,strings:内容 * 调用示列： * string Path = Server.MapPath(&quot;Default2.aspx&quot;); * string Strings = &quot;新追加内容&quot;; * DotNet.Utilities.FileOperate.FileAdd(Path, Strings); *****************************************/ /// &lt;summary&gt; /// 追加文件 /// &lt;/summary&gt; /// &lt;param name=&quot;Path&quot;&gt;文件路径&lt;/param&gt; /// &lt;param name=&quot;strings&quot;&gt;内容&lt;/param&gt; public static void FileAdd(string Path, string strings) &#123; StreamWriter sw = new StreamWriter(Path, true, Encoding.GetEncoding(&quot;gb2312&quot;)); //StreamWriter sw = File.AppendText(Path); sw.Write(strings); sw.Flush(); sw.Close(); sw.Dispose(); &#125; #endregion #region 拷贝文件 /**************************************** * 函数名称：FileCoppy * 功能说明：拷贝文件 * 参 数：OrignFile:原始文件,NewFile:新文件路径 * 调用示列： * string OrignFile = Server.MapPath(&quot;Default2.aspx&quot;); * string NewFile = Server.MapPath(&quot;Default3.aspx&quot;); * DotNet.Utilities.FileOperate.FileCoppy(OrignFile, NewFile); *****************************************/ /// &lt;summary&gt; /// 拷贝文件 /// &lt;/summary&gt; /// &lt;param name=&quot;OrignFile&quot;&gt;原始文件&lt;/param&gt; /// &lt;param name=&quot;NewFile&quot;&gt;新文件路径&lt;/param&gt; public static void FileCoppy(string OrignFile, string NewFile) &#123; File.Copy(OrignFile, NewFile, true); &#125; #endregion #region 删除文件 /**************************************** * 函数名称：FileDel * 功能说明：删除文件 * 参 数：Path:文件路径 * 调用示列： * string Path = Server.MapPath(&quot;Default3.aspx&quot;); * DotNet.Utilities.FileOperate.FileDel(Path); *****************************************/ /// &lt;summary&gt; /// 删除文件 /// &lt;/summary&gt; /// &lt;param name=&quot;Path&quot;&gt;路径&lt;/param&gt; public static void FileDel(string Path) &#123; File.Delete(Path); &#125; #endregion #region 移动文件 /**************************************** * 函数名称：FileMove * 功能说明：移动文件 * 参 数：OrignFile:原始路径,NewFile:新文件路径 * 调用示列： * string OrignFile = Server.MapPath(&quot;../说明.txt&quot;); * string NewFile = Server.MapPath(&quot;../../说明.txt&quot;); * DotNet.Utilities.FileOperate.FileMove(OrignFile, NewFile); *****************************************/ /// &lt;summary&gt; /// 移动文件 /// &lt;/summary&gt; /// &lt;param name=&quot;OrignFile&quot;&gt;原始路径&lt;/param&gt; /// &lt;param name=&quot;NewFile&quot;&gt;新路径&lt;/param&gt; public static void FileMove(string OrignFile, string NewFile) &#123; File.Move(OrignFile, NewFile); &#125; #endregion #region 在当前目录下创建目录 /**************************************** * 函数名称：FolderCreate * 功能说明：在当前目录下创建目录 * 参 数：OrignFolder:当前目录,NewFloder:新目录 * 调用示列： * string OrignFolder = Server.MapPath(&quot;test/&quot;); * string NewFloder = &quot;new&quot;; * DotNet.Utilities.FileOperate.FolderCreate(OrignFolder, NewFloder); *****************************************/ /// &lt;summary&gt; /// 在当前目录下创建目录 /// &lt;/summary&gt; /// &lt;param name=&quot;OrignFolder&quot;&gt;当前目录&lt;/param&gt; /// &lt;param name=&quot;NewFloder&quot;&gt;新目录&lt;/param&gt; public static void FolderCreate(string OrignFolder, string NewFloder) &#123; Directory.SetCurrentDirectory(OrignFolder); Directory.CreateDirectory(NewFloder); &#125; /// &lt;summary&gt; /// 创建文件夹 /// &lt;/summary&gt; /// &lt;param name=&quot;Path&quot;&gt;&lt;/param&gt; public static void FolderCreate(string Path) &#123; // 判断目标目录是否存在如果不存在则新建之 if (!Directory.Exists(Path)) Directory.CreateDirectory(Path); &#125; #endregion #region 创建目录 public static void FileCreate(string Path) &#123; FileInfo CreateFile = new FileInfo(Path); //创建文件 if (!CreateFile.Exists) &#123; FileStream FS = CreateFile.Create(); FS.Close(); &#125; &#125; #endregion #region 递归删除文件夹目录及文件 /**************************************** * 函数名称：DeleteFolder * 功能说明：递归删除文件夹目录及文件 * 参 数：dir:文件夹路径 * 调用示列： * string dir = Server.MapPath(&quot;test/&quot;); * DotNet.Utilities.FileOperate.DeleteFolder(dir); *****************************************/ /// &lt;summary&gt; /// 递归删除文件夹目录及文件 /// &lt;/summary&gt; /// &lt;param name=&quot;dir&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static void DeleteFolder(string dir) &#123; if (Directory.Exists(dir)) //如果存在这个文件夹删除之 &#123; foreach (string d in Directory.GetFileSystemEntries(dir)) &#123; if (File.Exists(d)) File.Delete(d); //直接删除其中的文件 else DeleteFolder(d); //递归删除子文件夹 &#125; Directory.Delete(dir, true); //删除已空文件夹 &#125; &#125; #endregion #region 将指定文件夹下面的所有内容copy到目标文件夹下面 果目标文件夹为只读属性就会报错。 /**************************************** * 函数名称：CopyDir * 功能说明：将指定文件夹下面的所有内容copy到目标文件夹下面 果目标文件夹为只读属性就会报错。 * 参 数：srcPath:原始路径,aimPath:目标文件夹 * 调用示列： * string srcPath = Server.MapPath(&quot;test/&quot;); * string aimPath = Server.MapPath(&quot;test1/&quot;); * DotNet.Utilities.FileOperate.CopyDir(srcPath,aimPath); *****************************************/ /// &lt;summary&gt; /// 指定文件夹下面的所有内容copy到目标文件夹下面 /// &lt;/summary&gt; /// &lt;param name=&quot;srcPath&quot;&gt;原始路径&lt;/param&gt; /// &lt;param name=&quot;aimPath&quot;&gt;目标文件夹&lt;/param&gt; public static void CopyDir(string srcPath, string aimPath) &#123; try &#123; // 检查目标目录是否以目录分割字符结束如果不是则添加之 if (aimPath[aimPath.Length - 1] != Path.DirectorySeparatorChar) aimPath += Path.DirectorySeparatorChar; // 判断目标目录是否存在如果不存在则新建之 if (!Directory.Exists(aimPath)) Directory.CreateDirectory(aimPath); // 得到源目录的文件列表，该里面是包含文件以及目录路径的一个数组 //如果你指向copy目标文件下面的文件而不包含目录请使用下面的方法 //string[] fileList = Directory.GetFiles(srcPath); string[] fileList = Directory.GetFileSystemEntries(srcPath); //遍历所有的文件和目录 foreach (string file in fileList) &#123; //先当作目录处理如果存在这个目录就递归Copy该目录下面的文件 if (Directory.Exists(file)) CopyDir(file, aimPath + Path.GetFileName(file)); //否则直接Copy文件 else File.Copy(file, aimPath + Path.GetFileName(file), true); &#125; &#125; catch (Exception ee) &#123; throw new Exception(ee.ToString()); &#125; &#125; #endregion #region 获取指定文件夹下所有子目录及文件(树形) /**************************************** * 函数名称：GetFoldAll(string Path) * 功能说明：获取指定文件夹下所有子目录及文件(树形) * 参 数：Path:详细路径 * 调用示列： * string strDirlist = Server.MapPath(&quot;templates&quot;); * this.Literal1.Text = DotNet.Utilities.FileOperate.GetFoldAll(strDirlist); *****************************************/ /// &lt;summary&gt; /// 获取指定文件夹下所有子目录及文件 /// &lt;/summary&gt; /// &lt;param name=&quot;Path&quot;&gt;详细路径&lt;/param&gt; public static string GetFoldAll(string Path) &#123; string str = &quot;&quot;; DirectoryInfo thisOne = new DirectoryInfo(Path); str = ListTreeShow(thisOne, 0, str); return str; &#125; /// &lt;summary&gt; /// 获取指定文件夹下所有子目录及文件函数 /// &lt;/summary&gt; /// &lt;param name=&quot;theDir&quot;&gt;指定目录&lt;/param&gt; /// &lt;param name=&quot;nLevel&quot;&gt;默认起始值,调用时,一般为0&lt;/param&gt; /// &lt;param name=&quot;Rn&quot;&gt;用于迭加的传入值,一般为空&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string ListTreeShow(DirectoryInfo theDir, int nLevel, string Rn)//递归目录 文件 &#123; DirectoryInfo[] subDirectories = theDir.GetDirectories();//获得目录 foreach (DirectoryInfo dirinfo in subDirectories) &#123; if (nLevel == 0) &#123; Rn += &quot;├&quot;; &#125; else &#123; string _s = &quot;&quot;; for (int i = 1; i &lt;= nLevel; i++) &#123; _s += &quot;│&amp;nbsp;&quot;; &#125; Rn += _s + &quot;├&quot;; &#125; Rn += &quot;&lt;b&gt;&quot; + dirinfo.Name.ToString() + &quot;&lt;/b&gt;&lt;br /&gt;&quot;; FileInfo[] fileInfo = dirinfo.GetFiles(); //目录下的文件 foreach (FileInfo fInfo in fileInfo) &#123; if (nLevel == 0) &#123; Rn += &quot;│&amp;nbsp;├&quot;; &#125; else &#123; string _f = &quot;&quot;; for (int i = 1; i &lt;= nLevel; i++) &#123; _f += &quot;│&amp;nbsp;&quot;; &#125; Rn += _f + &quot;│&amp;nbsp;├&quot;; &#125; Rn += fInfo.Name.ToString() + &quot; &lt;br /&gt;&quot;; &#125; Rn = ListTreeShow(dirinfo, nLevel + 1, Rn); &#125; return Rn; &#125; /**************************************** * 函数名称：GetFoldAll(string Path) * 功能说明：获取指定文件夹下所有子目录及文件(下拉框形) * 参 数：Path:详细路径 * 调用示列： * string strDirlist = Server.MapPath(&quot;templates&quot;); * this.Literal2.Text = DotNet.Utilities.FileOperate.GetFoldAll(strDirlist,&quot;tpl&quot;,&quot;&quot;); *****************************************/ /// &lt;summary&gt; /// 获取指定文件夹下所有子目录及文件(下拉框形) /// &lt;/summary&gt; /// &lt;param name=&quot;Path&quot;&gt;详细路径&lt;/param&gt; ///&lt;param name=&quot;DropName&quot;&gt;下拉列表名称&lt;/param&gt; ///&lt;param name=&quot;tplPath&quot;&gt;默认选择模板名称&lt;/param&gt; public static string GetFoldAll(string Path, string DropName, string tplPath) &#123; string strDrop = &quot;&lt;select name=\\&quot;&quot; + DropName + &quot;\\&quot; id=\\&quot;&quot; + DropName + &quot;\\&quot;&gt;&lt;option value=\\&quot;\\&quot;&gt;--请选择详细模板--&lt;/option&gt;&quot;; string str = &quot;&quot;; DirectoryInfo thisOne = new DirectoryInfo(Path); str = ListTreeShow(thisOne, 0, str, tplPath); return strDrop + str + &quot;&lt;/select&gt;&quot;; &#125; /// &lt;summary&gt; /// 获取指定文件夹下所有子目录及文件函数 /// &lt;/summary&gt; /// &lt;param name=&quot;theDir&quot;&gt;指定目录&lt;/param&gt; /// &lt;param name=&quot;nLevel&quot;&gt;默认起始值,调用时,一般为0&lt;/param&gt; /// &lt;param name=&quot;Rn&quot;&gt;用于迭加的传入值,一般为空&lt;/param&gt; /// &lt;param name=&quot;tplPath&quot;&gt;默认选择模板名称&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string ListTreeShow(DirectoryInfo theDir, int nLevel, string Rn, string tplPath)//递归目录 文件 &#123; DirectoryInfo[] subDirectories = theDir.GetDirectories();//获得目录 foreach (DirectoryInfo dirinfo in subDirectories) &#123; Rn += &quot;&lt;option value=\\&quot;&quot; + dirinfo.Name.ToString() + &quot;\\&quot;&quot;; if (tplPath.ToLower() == dirinfo.Name.ToString().ToLower()) &#123; Rn += &quot; selected &quot;; &#125; Rn += &quot;&gt;&quot;; if (nLevel == 0) &#123; Rn += &quot;┣&quot;; &#125; else &#123; string _s = &quot;&quot;; for (int i = 1; i &lt;= nLevel; i++) &#123; _s += &quot;│&amp;nbsp;&quot;; &#125; Rn += _s + &quot;┣&quot;; &#125; Rn += &quot;&quot; + dirinfo.Name.ToString() + &quot;&lt;/option&gt;&quot;; FileInfo[] fileInfo = dirinfo.GetFiles(); //目录下的文件 foreach (FileInfo fInfo in fileInfo) &#123; Rn += &quot;&lt;option value=\\&quot;&quot; + dirinfo.Name.ToString() + &quot;/&quot; + fInfo.Name.ToString() + &quot;\\&quot;&quot;; if (tplPath.ToLower() == fInfo.Name.ToString().ToLower()) &#123; Rn += &quot; selected &quot;; &#125; Rn += &quot;&gt;&quot;; if (nLevel == 0) &#123; Rn += &quot;│&amp;nbsp;├&quot;; &#125; else &#123; string _f = &quot;&quot;; for (int i = 1; i &lt;= nLevel; i++) &#123; _f += &quot;│&amp;nbsp;&quot;; &#125; Rn += _f + &quot;│&amp;nbsp;├&quot;; &#125; Rn += fInfo.Name.ToString() + &quot;&lt;/option&gt;&quot;; &#125; Rn = ListTreeShow(dirinfo, nLevel + 1, Rn, tplPath); &#125; return Rn; &#125; #endregion #region 获取文件夹大小 /**************************************** * 函数名称：GetDirectoryLength(string dirPath) * 功能说明：获取文件夹大小 * 参 数：dirPath:文件夹详细路径 * 调用示列： * string Path = Server.MapPath(&quot;templates&quot;); * Response.Write(DotNet.Utilities.FileOperate.GetDirectoryLength(Path)); *****************************************/ /// &lt;summary&gt; /// 获取文件夹大小 /// &lt;/summary&gt; /// &lt;param name=&quot;dirPath&quot;&gt;文件夹路径&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static long GetDirectoryLength(string dirPath) &#123; if (!Directory.Exists(dirPath)) return 0; long len = 0; DirectoryInfo di = new DirectoryInfo(dirPath); foreach (FileInfo fi in di.GetFiles()) &#123; len += fi.Length; &#125; DirectoryInfo[] dis = di.GetDirectories(); if (dis.Length &gt; 0) &#123; for (int i = 0; i &lt; dis.Length; i++) &#123; len += GetDirectoryLength(dis[i].FullName); &#125; &#125; return len; &#125; #endregion #region 获取指定文件详细属性 /**************************************** * 函数名称：GetFileAttibe(string filePath) * 功能说明：获取指定文件详细属性 * 参 数：filePath:文件详细路径 * 调用示列： * string file = Server.MapPath(&quot;robots.txt&quot;); * Response.Write(DotNet.Utilities.FileOperate.GetFileAttibe(file)); *****************************************/ /// &lt;summary&gt; /// 获取指定文件详细属性 /// &lt;/summary&gt; /// &lt;param name=&quot;filePath&quot;&gt;文件详细路径&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string GetFileAttibe(string filePath) &#123; string str = &quot;&quot;; System.IO.FileInfo objFI = new System.IO.FileInfo(filePath); str += &quot;详细路径:&quot; + objFI.FullName + &quot;&lt;br&gt;文件名称:&quot; + objFI.Name + &quot;&lt;br&gt;文件长度:&quot; + objFI.Length.ToString() + &quot;字节&lt;br&gt;创建时间&quot; + objFI.CreationTime.ToString() + &quot;&lt;br&gt;最后访问时间:&quot; + objFI.LastAccessTime.ToString() + &quot;&lt;br&gt;修改时间:&quot; + objFI.LastWriteTime.ToString() + &quot;&lt;br&gt;所在目录:&quot; + objFI.DirectoryName + &quot;&lt;br&gt;扩展名:&quot; + objFI.Extension; return str; &#125; #endregion &#125; &#125; 本文转载自 C#封装的常用文件操作类实例","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"文件操作类","slug":"文件操作类","permalink":"http://example.com/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%B1%BB/"}],"author":"learnqiu"},{"title":"NGSA-2 建模相关","slug":"tech-nsga2-02","date":"2021-03-21T07:34:59.000Z","updated":"2021-03-30T07:04:48.729Z","comments":true,"path":"posts/archives/41889.html/","link":"","permalink":"http://example.com/posts/archives/41889.html/","excerpt":"","text":"NGSA-2 建模相关1.目标函数1.1 最大完工时间 取最小 单位：min 即 【各工件完工时间】的最大值 1.2 最大总延迟时间 取最小 单位：min 即 【各工件完成时间 - 各工件交货期】的最大值，若小于0，则延迟时间为0 1.3 设备总负荷 取最小 单位： 即 【各机器加工时间之和】 1.4 能耗总量 空转能耗：即 设备固定功率（单位时间能耗）* 设备空载时间 加工能耗：即 设备加工功率（单位时间能耗）* 设备加工时间 转移能耗：不考虑 车间固有能耗：即 车间固定功率 * 最大完工时间","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"NGSA-2","slug":"NGSA-2","permalink":"http://example.com/tags/NGSA-2/"}],"author":"learnqiu"},{"title":"tech-tomcat-01","slug":"tech-tomcat-01","date":"2021-03-20T14:42:43.000Z","updated":"2021-03-30T07:04:48.744Z","comments":true,"path":"posts/archives/32382.html/","link":"","permalink":"http://example.com/posts/archives/32382.html/","excerpt":"","text":"3.Tomcat3.1 Tomcat安装配置 3.2 Tomcat的启动和配置文件夹的存放内容 3.3 发布一个Web网站","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"learnqiu"},{"title":"学习笔记：JavaWeb","slug":"tech-javaWeb-01","date":"2021-03-20T11:37:55.000Z","updated":"2021-03-30T09:05:29.156Z","comments":true,"path":"posts/archives/39768.html/","link":"","permalink":"http://example.com/posts/archives/39768.html/","excerpt":"","text":"学习笔记：JavaWeb1.基本概念1.1 前言 1.2 web应用程序 1.3 静态web 1.4 动态web 2.Web服务器2.1 技术 2.2 Web服务器 3.Tomcat3.1 Tomcat安装配置 3.2 Tomcat的启动和配置文件夹的存放内容 3.3 发布一个Web网站 4.HTTP4.1 什么是HTTP 4.1 两个时代 4.3 HTTP请求 4.3 HTTP响应 5.Maven 5.1 Maven项目架构管理工具 5.2 下载安装Maven​ 官网： ​ 下载完，解压即可； 5.3 配置环境变量 5.4 阿里云镜像 &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; 5.5 本地仓库 5.6 在IDEA中使用Maven ​ 3.等待项目初始化完毕 ​ 4.观察maven仓库中多少什么文件 ​ 5.IDEA的maven设置 ​ IDEA项目创建成功后，看一眼Maven的配置 6.到这里，maven在IDEA的配置和使用已经完毕 5.7 创建一个普通的maven项目","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"}],"author":"learnqiu"},{"title":"学习笔记：网络编程","slug":"tech-netCode-01","date":"2021-03-18T06:33:13.000Z","updated":"2021-03-20T12:41:42.436Z","comments":true,"path":"posts/archives/50819.html/","link":"","permalink":"http://example.com/posts/archives/50819.html/","excerpt":"","text":"网络编程1.1 概述 1.2 网络通信的要素 1.3 IP –》代码实现IP package javalearn.NetTest; import java.net.InetAddress; import java.net.UnknownHostException; //03 IP编程 //测试IP public class NetTest01 &#123; public static void main(String[] args) &#123; try &#123; //查询本机地址 InetAddress iNetAddress1 = InetAddress.getByName(&quot;127.0.0.1&quot;);//没有构造器,通过方法获取 System.out.println(iNetAddress1); InetAddress iNetAddress2 = InetAddress.getByName(&quot;localhost&quot;); System.out.println(iNetAddress2); InetAddress iNetAddress3 = InetAddress.getLocalHost(); System.out.println(iNetAddress3); //查询网络ip地址 InetAddress iNetAddress4 = InetAddress.getByName(&quot;www.baidu.com&quot;); System.out.println(iNetAddress4); //常用方法 System.out.println(iNetAddress4.getAddress()); System.out.println(iNetAddress4.getCanonicalHostName());//规范的名字 System.out.println(iNetAddress4.getHostAddress());//IP System.out.println(iNetAddress4.getHostName());//域名，或者自己电脑的名字 &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 1.4 端口 netstat -ano #查看所有端口 netstat -ano|findstr &quot;5900&quot; #查看指定端口 tasklist|findstr &quot;8696&quot; #查看指定端口的进程 ctrl+shift+ESC #打开任务管理器 代码实现如下： package javalearn.NetTest; import java.net.InetSocketAddress; //端口 public class NetTest02 &#123; public static void main(String[] args) &#123; InetSocketAddress iNetSocketAddress = new InetSocketAddress(&quot;127.0.0.1&quot;, 8080); InetSocketAddress iNetSocketAddress2 = new InetSocketAddress(&quot;localhost&quot;, 8080); System.out.println(iNetSocketAddress); System.out.println(iNetSocketAddress2); System.out.println(iNetSocketAddress.getAddress()); System.out.println(iNetSocketAddress.getHostName());//地址 System.out.println(iNetSocketAddress.getPort());//端口 &#125; &#125; 1.5 通信协议 1.6 TCP发送消息客户端 ​ 1.连接服务器 Socket ​ 2.发送消息 package javalearn.NetTest; import java.io.IOException; import java.io.OutputStream; import java.net.InetAddress; import java.net.Socket; import java.net.UnknownHostException; //客户端 public class NetTest04 &#123; public static void main(String[] args) &#123; Socket socket = null; OutputStream os = null; try &#123; //1.要知道服务器的地址，端口号 InetAddress serverIP = InetAddress.getByName(&quot;127.0.0.1&quot;); int port = 9999; //2.创建一个socket连接 socket = new Socket(serverIP, port); //3.发送消息 os = socket.getOutputStream(); os.write(&quot;你好！&quot;.getBytes()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if (socket!=null)&#123; socket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (os!=null) &#123; os.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 服务器 ​ 1.建立服务的端口 ServerSocket ​ 2.等待用户的连接 accept ​ 3.接收用户的消息 package javalearn.NetTest; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.net.ServerSocket; import java.net.Socket; //服务器端 public class NetTest03 &#123; public static void main(String[] args) &#123; ServerSocket serverSocket = null; Socket socket = null; InputStream is = null; ByteArrayOutputStream baos = null; try &#123; //1.我得有一个地址 serverSocket = new ServerSocket(9999); while (true)&#123;//循环接收消息 //2.等待客户端连接过来 socket = serverSocket.accept(); //3.读取客户端的消息 is = socket.getInputStream(); /** //一般写法,若中文超过1024大小，就断掉了，输出后乱码 byte[] buffer = new byte[1024]; int len; while ((len = is.read(buffer))!=-1)&#123; String msg = new String(buffer,0,len); System.out.println(msg); &#125; */ //管道流 不会断 baos = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len; while ((len = is.read(buffer))!=-1)&#123; baos.write(buffer,0,len); &#125; System.out.println(baos.toString()); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; //关闭资源 //先开后关! try &#123; if (baos!=null)&#123; baos.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (is!=null)&#123; is.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (socket!=null)&#123; socket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (serverSocket!=null)&#123; serverSocket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 文件上传客户端 package javalearn.NetTest; import sun.nio.cs.ext.ISO2022_CN; import java.io.*; import java.net.InetAddress; import java.net.Socket; import java.net.UnknownHostException; public class NetTest05 &#123; public static void main(String[] args) throws Exception &#123; //1.创建一个Socket连接 Socket socket = new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;), 9000); //2.创建一个输出流 OutputStream os = socket.getOutputStream(); //3.读取文件 FileInputStream fis = new FileInputStream(new File(&quot;src/javalearn/NetTest/note.markdown&quot;)); //4.写出文件 byte[] buffer = new byte[1024]; int len = 0; while ((len = fis.read(buffer))!=-1)&#123; os.write(buffer,0,len); &#125; //通知服务器，我已经结束了 socket.shutdownOutput();//我已经传输完了 //确定服务器接收完毕，才能够断开连接 InputStream inputStream = socket.getInputStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buffer2 = new byte[1024]; int len2 = 0; while ((len2 = fis.read(buffer2))!=-1)&#123; baos.write(buffer2,0,len); &#125; //5.关闭资源 baos.close(); inputStream.close(); fis.close(); os.close(); socket.close(); &#125; &#125; 服务端 package javalearn.NetTest; import java.io.*; import java.net.InetAddress; import java.net.ServerSocket; import java.net.Socket; import java.net.UnknownHostException; public class NetTest06 &#123; public static void main(String[] args) throws Exception &#123; //1.创建服务端端口 ServerSocket serverSocket = new ServerSocket(9000); //2.监听客户端的连接 Socket socket = serverSocket.accept();//阻塞式监听，会一直等待客户端连接 //3.获取输入流 InputStream is = socket.getInputStream(); //4.文件输出 FileOutputStream fos = new FileOutputStream(new File(&quot;receive.markdown&quot;)); byte[] buffer = new byte[1024]; int len; while ((len=is.read(buffer))!=-1)&#123; fos.write(buffer,0,len); &#125; //通知客户端我接收完毕了 OutputStream os = socket.getOutputStream(); os.write(&quot;我接收完毕了，你可以断开了&quot;.getBytes()); //关闭资源 os.close(); fos.close(); is.close(); socket.close(); &#125; &#125; Tomcat服务端 自定义 Tomcat服务器 : Java后台开发 客户端 自定义 浏览器 1.7 UDP发短信：不需要建立连接，需要知道对方的地址。 发送消息package javalearn.NetTest; //UDP传输，发送消息 //不需要连接服务器 import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.net.UnknownHostException; public class NetTest07 &#123; public static void main(String[] args) throws Exception &#123; //1.建立一个Socket DatagramSocket socket = new DatagramSocket(); //2.建个包 //发送给谁 InetAddress localhost = InetAddress.getByName(&quot;localhost&quot;); int port = 9090; String msg =&quot;你好啊，服务器！&quot;; //数据，数据的长度起始，要发给谁 DatagramPacket packet = new DatagramPacket(msg.getBytes(), 0, msg.getBytes().length, localhost, port); //3.发送包 IO流 socket.send(packet); //4.关闭流 socket.close(); &#125; &#125; 消息接收端package javalearn.NetTest; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; //UDP传输，接收消息 //还是要等待客户端的连接 public class NetTest08 &#123; public static void main(String[] args) throws Exception &#123; //开放端口 DatagramSocket socket = new DatagramSocket(9090); //接收数据包 byte[] buffer = new byte[1024]; DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length);//接收 socket.receive(packet);//阻塞接收 System.out.println(new String(packet.getData(),0,packet.getLength())); System.out.println(packet.getAddress()); //关闭连接 socket.close(); &#125; &#125; 咨询发送端 package javalearn.NetTest; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.*; //UOP实现咨询 //发送方 public class NetTest09 &#123; public static void main (String[] args) throws Exception &#123; DatagramSocket socket = new DatagramSocket(8888); //准备数据，控制台读取System.in BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); while (true)&#123; String data = reader.readLine(); byte[] datas = data.getBytes(); DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(&quot;localhost&quot;, 6666)); socket.send(packet); if (data.equals(&quot;bye&quot;))&#123; break; &#125; &#125; socket.close(); &#125; &#125; 接收端 package javalearn.NetTest; import java.lang.String; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; //UOP实现咨询 //接收方 public class NetTest10 &#123; public static void main(String[] args) throws Exception &#123; DatagramSocket socket = new DatagramSocket(6666); while (true)&#123; //准备接收包裹 byte[] container = new byte[1024]; DatagramPacket packet = new DatagramPacket(container, 0, container.length); socket.receive(packet);//阻塞式接收包裹 //断开连接 bye byte[] data = packet.getData(); String receiveData = new String(data, 0, data.length); System.out.println(receiveData); if (receiveData.equals(&quot;bye&quot;))&#123; break; &#125; &#125; socket.close(); &#125; &#125; 在线咨询两个人都可以是发送方，也可以是接收方 1.8 URLhttps://www.zhihu.com/hot 统一资源定位符：定位资源的，定位互联网上的一个资源 DNS域名解析 域名-》IP 协议：//IP地址：端口/项目名/资源","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"author":"learnqiu"},{"title":"遗传算法求解车间调度问题（附MATLAB代码）","slug":"tech-gccode-01","date":"2021-03-17T07:35:57.000Z","updated":"2021-03-20T12:41:42.425Z","comments":true,"path":"posts/archives/11111.html/","link":"","permalink":"http://example.com/posts/archives/11111.html/","excerpt":"","text":"遗传算法操作流程接下来给出遗传算法的框架： 1、初始化：依据每个种群的特征随机生成第一代种群的全部个体； 2、求个体适应度：计算每个个体的适应度； 3、选择过程：依据一定的选择规范，选出一部分优秀个体参与交叉和变异操作； 4、交叉过程：群体中两两配对，交换部分染色体基因，完成交叉操作； 5、变异过程：随机改变个体中的部分基因，来实现变异操作； 6、终止判断：若新一代种群满足终止条件，停止算法迭代，记录此时的最优解为问题的最优解；否则，迭代次数加1，返回步骤2； 车间调度问题描述车间调度是指根据产品制造的合理需求分配加工车间顺序，从而达到合理利用产品制造资源、提高企业经济效益的目的。车间调度问题从数学上可以描述为有n个待加工的零件要在m台机器上加工已知各工件的加工时间，优化目标是如何确定工件的加工顺序以及每阶段工件在机器上的分配情况，使得最大完工时间极小化。 遗传算法求解车间调度问题方法1.个体编码当待加工的工件总数为k，工件n**i的加工工序共为m**j时，则个体表示为长度为，染色体前半部分表示所有工件在机器上的加工工序，后半部分表示工件每道工序的加工机器序号。如个体 该个体表达了4个加工工序都是2次的工件在3台机器上的加工顺序。其中前8位表示工件的加工顺序，为工件2-&gt;工件4-&gt;工件3-&gt;工件1-&gt;工件1-&gt;工件2-&gt;工件3-&gt;工件4；9到16位表示加工机器，依次为机器2-&gt;机器1-&gt;机器3-&gt;机器3-&gt;机器2-&gt;机器2-&gt;机器1-&gt;机器3。 2.适应度值染色体的适应度值为全部工件的完成时间，适应度值计算公式为 其中，time指全部任务完成时间。全部工件完成时间越短，该染色体越好。 3.选择操作采用轮盘赌法选择适应度较好的染色体，个体选择概率为 其中，表示染色体i在每次选择中被选中的概率。 4.交叉操作交叉操作首先从种群中随机选取两个染色体，并取出每个染色体的前位进行交叉。操作方法如下：交叉位置为5，只对个体前位进行交叉。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"遗传算法","slug":"遗传算法","permalink":"http://example.com/tags/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"},{"name":"车间调度问题","slug":"车间调度问题","permalink":"http://example.com/tags/%E8%BD%A6%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/"}],"author":"learnqiu"},{"title":"面试相关","slug":"tech-pcRel-01","date":"2021-03-17T05:47:49.000Z","updated":"2021-03-20T12:41:42.449Z","comments":true,"path":"posts/archives/18618.html/","link":"","permalink":"http://example.com/posts/archives/18618.html/","excerpt":"","text":"作者：shopee新加坡内推链接：https://www.nowcoder.com/discuss/536760?type=2&amp;order=0&amp;pos=7&amp;page=1&amp;channel=-1&amp;source_id=discuss_tag_nctrack来源：牛客网 神策数据一面 代码题：二叉树的层次遍历，每一层的顺序相反 HashMap, loadFactory，多线程访问HashMap会出现什么问题， ConcurrentHashMap Java怎么判断一个对象是否存活 常见的垃圾回收器 堆，场景，堆排序 HashTable， 哈希冲突解决方案 进程和线程的区别，进程间的通信 kill 的原理， kill -9 和 kill -15的区别 TCP和UDP的区别和场景 浏览器输入一个淘宝网址，发生了什么 （负载均衡，图片怎么返回） 神策数据二面 项目是怎么做的 集群有多少机器，能完成多少并发量，项目怎么优化 Redis支持的数据结构， Redis如何支持高并发 Linux 看磁盘大小， 查看进程占用的端口 一个请求过来，后台怎么做？ Redis和MySQL如何保证数据一致？ 如何保证不超卖 少买 MySQL的数据如何更新到Redis 熟悉什么设计模式 两道代码题，不怎么记得了，第二道口述思路 MySQL索引结构 神策数据三面 问了一下基本情况 项目的架构，中间件在系统中有什么作用？Redis里面存了什么数据 下单的流程是怎么样的 MQ异步，向前端返回什么数据 前端怎么做轮询 Redis和MySQL的数据一致性 实习的项目 MySQL适合放在k8s上吗 有状态服务和无状态服务差异，为什么无状态服务比较容易部署？ （无状态服务可以通过一些请求获取数据） 后面的规划？不读研，想工作？想去哪里工作？为什么想去北京？ （无HR面） TCP和UDP的区别和优缺点及应用场景一、区别 TCP 是面向连接的，UDP 是面向无连接的 TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。 TCP 保证数据正确性，UDP 可能丢包 TCP 保证数据顺序，UDP 不保证 UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。 TCP数据传输慢，UDP数据传送快 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。 TCP对系统资源要求较多，UDP对系统资源要求较少。 TCP 是面向字节流的，UDP 是基于数据报的。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}],"author":"learnqiu"},{"title":"学习笔记：NSGA-II","slug":"tech-NSGA2-01","date":"2021-03-12T08:03:57.000Z","updated":"2021-03-12T11:56:28.433Z","comments":true,"path":"posts/archives/19218.html/","link":"","permalink":"http://example.com/posts/archives/19218.html/","excerpt":"","text":"学习笔记：NSGA-II算法NSGA-II：基于 pareto 的改进非支配排序的遗传算法 进行多目标优化时，通常面临多个目标函数无法同时达到最优的情况，为了解决这一矛盾，引入Pareto-Optimality的概念 Pareto-Optimality通常，多目标优化的一般形式为： 经过处理，可以化为以下形式： 其中 f1(x),f2(x),…,fn(x) 为目标函数，其全部都是求最小值的形式 以下针对两个目标函数进行讨论： 有几个目标函数便为几维空间，有两个目标函数Time(f1(x)),Cost(f2(x)), 可以画出图像： 随后引入几个概念： 非支配解：假设任何二解S1 及S2 对所有目标而言，S1均优于S2，则我们称S1 支配S2，若S1 的解没有被其他解所支配，则S1 称为非支配解（不受支配解），也称Pareto解 支配解：若解S2的所有目标均劣于S1，则称S1优于S2，也称S1支配S2 ，S2为受支配解。 因此现在的首要任务是寻找解空间里面所有的Pareto解，找到所有Pareto解之后，这些解组成的平面叫做Pareto前沿面（Non-dominated front）。在目标函数较多时，前沿面通常为超曲面。 非支配解排序（Non-dominated Sorting） 设所有解的集合为S，现从中找出非支配解集合，记为F1 令S=S-F1，从S中再找出非支配解集合，记为F2 重复第二步，直到S为空集 将每次找出的非支配解进行排序如下： {F1,F2,…,Fn} 在途中画出Fi集合中对应点，并连线，则构成了n个pareto曲面，分别编号为Non-dominated Front 1，Non-dominated Front 2… 以上述表格中数据为例：F1={A,B,D,F}, F2={C,E,D}, F3={H,I} 画出相应图形： 在第一个前沿面上的解具有最大的适应度，序数越大则适应度越小。序号小的前沿面上的解可以支配序号大的前沿面上的解。 同一前沿面上解的排序-拥挤度（Crowding Distances）针对第一个前沿面来说，其中包含了A,B,D,F四个解，如何评判这四个解的适应度大小呢？由此引入了拥挤度的概念。 拥挤度的计算： 只考虑同一前沿面上的解，设定位于前沿面两端边界点的拥挤度为∞。 对于不在两端的点，其拥挤度主要与其相邻两个点有关 解i 的拥挤距离等于它在同一级相邻的两个解 i-1 与 i+1 总成的矩形的边长之和。 拥挤度越小则对应该解越重要 比较通俗的理解：拥挤度越小就说明该解与其他解相似程度不高，保留拥挤度较小的点相当于保存了解的多样性 所以说，确定解的适应度大小顺序应该先判断该解在哪个前沿面上，如果在同一个前沿面上，则再计算拥挤度进行判断 与遗传算法结合与普通遗传算法步骤大概相同，初始化随机取几个解，进行编码，交叉互换，突变生成子代 但是，在生成子代后，需要与父代混合，从中挑选出适应度较高的解重新形成子代，再进行新的一轮迭代。 举例说明： 1.针对一个两目标优化问题，初始化随机取出10个解记为F，经过计算得到子一代为P 此时将P,F混合，形成新的解集S 2.针对S，进行上面所介绍的非支配解排序，计算拥挤度，最终得出这12个解的适应度大小顺序，从中取适应度较大的10个点生成新的子代（维持和父代个数相同），带入算法进行新一轮迭代 子代父代混合筛选生成新的子代，好像叫做精英策略 任何启发式算法均有两个方面组成：加快收敛的操作和在收敛过程中保持解的多样性的操作，两种操作相互作用，以至于找到一个合适的收敛速度，减少计算时间，同时避免陷入局部最优 对于NSGA来说，其规则仍然符合这两个准则： 本算法并不是只取最优的前沿面，而是将所有前沿面均纳入考虑范围内，是为了体现解的多样性，防止陷入局部最优 计算拥挤度是为了保存下来相似程度较低的解，保持解空间的多样性 使用精英策略是为了加速收敛，更快的除去劣解 以上内容转载自 知乎文章 NSGA2 遗传算法解决多目标优化 作者:骑着象拔蚌环游","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"NSGA-II","slug":"NSGA-II","permalink":"http://example.com/tags/NSGA-II/"},{"name":"遗传算法","slug":"遗传算法","permalink":"http://example.com/tags/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"},{"name":"pareto","slug":"pareto","permalink":"http://example.com/tags/pareto/"}],"author":"learnqiu"},{"title":"学习笔记：JavaSE 基础知识","slug":"tech-java-02","date":"2021-03-12T06:58:48.000Z","updated":"2021-03-13T06:15:23.275Z","comments":true,"path":"posts/archives/5041.html/","link":"","permalink":"http://example.com/posts/archives/5041.html/","excerpt":"","text":"学习笔记：JavaSE 基础知识一、Java 开发环境搭建1.Java基本特性简单性：底层是C++实现，但是JAVA不需要操作指针，且为单继承，简单很多 面向对象：JAVA提供了封装、继承、多态机制 健壮性：JAVA有GC机制 跨平台：JVM屏蔽了操作系统间的差异。一次编译，到处运行。 2.JDK,JRE,JVM之间的关系JDK:JAVA软件开发工具包，开发人员必须安装的，不同操作系统需要安装不同的的JDK，安装完成后会自动安装对应系统的JRE和JVM。 JRE:JAVA运行时环境，包含了运行JVM标准实现和JAVA核心类库 JVM:JAVA虚拟机，用于java跨平台。 3.JAVA程序的加载和运行分为编译和运行两个阶段，可以在不同的操作系统分别进行编译和运行，一次编译，到处运行。 程序员编写的.java结尾的文件称为JAVA源文件，使用JDK中的javac.exe程序可以对源文件进行编译操作，程序有语法错误则编译失败，编译成功则生成一个或多个.class文件，称为字节码文件。字节码文件不是二进制文件，否则操作系统就可以进行识别执行了。生成的字节码文件，可通过JRE中的java.exe程序进行执行，在运行阶段，首先类加载器会将字节码文件加载到JVM中，JVM将字节码文件解释称为可以供操作系统解释执行的二进制文件。 4.JDK的bin目录​ bin目录下存放的都是运行Java程序相关的命令。 图中包含 java.exe 和 javac.exe的安装位置 5.编写第一个程序新建一个文件HelloWorld.java。写入如下内容。 public class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println(&quot;Hello World&quot;); &#125; &#125; 程序编译及运行操作 将java源文件放到jdk/bin目录，可以直接运行javac命令，说明windows 操作系统默认是从当前所在的路径下查找可执行命令文件的 -》将javac.exe所在路径添加到系统的环境变量中 windows 操作系统到底是如何搜索命令文件的呢？ ​ 实际上它会先在当前路径下找，找不到的时候会自动去环境变量path 的路径中查找，找到则执行该命令，找不到则在DOS 窗口中提示错误信息。 执行java命令时，只能用 Java+类名的方式，如：java HelloWorld 执行后，启动类加载器，类加载器将.class字节码文件装载到JVM中。 关于Java命令 1.默认情况下类加载器只从当前路径下查找； 2.当设置环境变量classpath=E:\\的时候，类加载器只去E:\\目录下加载class 文件了，不再从当前目录下加载，也不会去其它目录下加载； 3.若配置为classpath=.;xxxx.jar，它表示的含义是类加载器可以从当前路径下加载，也可以去指定的jar 包中加载字节码文件了 所以一般执行时，都先用cd命令切换到字节码所在的路径，在进行java命令的执行。 6.Java的注释的三种方式Java 语言的注释包括三种方式，它们分别是： 第一种：单行注释，语法格式如下： // 单行注释，两个正斜杠后面的内容被注释 第二种：多行注释，语法格式如下： /* * 这里的注释信息为多行注释： * 第1 行注释信息 * 第2 行注释信息 */ 第三种：javadoc 注释。 注意：对于javadoc 注释来说，这里的注释会被JDK bin 目录下的javadoc.exe 命令解析并生成帮助文档（生成帮助文档后期做项目的时候大家会接触到的）。 /** * 这里的信息是javadoc 注释 * @author 作者名字 * @version 版本号 * @since 自从哪个版本号开始就存在了 */ 注意：对于javadoc 注释来说，这里的注释会被JDK bin 目录下的javadoc.exe 命令解析并生成帮助文档（生成帮助文档后期做项目的时候大家会接触的）。 7.public class 和 class的区别（掌握）1）一个java 源文件中可以定义多个class，并且在编译的时候一个class 会对应编译生成一个class 字节码文件。 2）如果定义public class的类，只能定义一个，并且要求此类名必须和java源文件名保持一致。 3）任何一个class中都可以设定程序入口，也就是说任何一个class中都可以写main方法（主方法）,想从哪个入口进去执行，则让类加载器先加载对应的类即可。 二、标识符与关键字1.标识符含义标识符是指用来标识某个实体的一个符号，用于给变量、常量、函数、语句块等命名。如下： 类名，例如：Student 学生类、User 用户类、Product 商品类、Order 订单类等。 接口名，例如：Runable 可运行的、Comparable 可比较的等。 变量名，例如：name 名字、age 年龄、birth 生日、length 长度等。 方法名，例如：login 登录、logout 登出、eat 吃、drink 喝等。 常量名，例如：LOGIN_SUCCESS、ACCESS_TOKEN 等。 2.标识符命名规则（掌握） 标识符只能由数字、字母、下划线“_”、美元符号“$”组成，不能含有其它符号。 标识符不能以数字开始。 java 关键字和保留字不能作为标识符。 标识符严格区分大小写。 标识符理论上没有长度限制。 注意：汉字也是合法的标识符，比如：字 3.标识符命名规范（掌握） 见名知意 驼峰命名方式 类名、接口名首字母大写，后面每个单词首字母大写，这是遵守驼峰命名方式的； 变量名、方法名首字母小写，后面每个单词首字母大写，这也是遵守驼峰命名方式的； 常量名全部大写，单词和单词之间使用“_”衔接，为了表示清楚含义，不要怕单词长，例如：INT_MAX_VALUE 则表示int 类型最大值 4.关键字关键字指编程语言中事先定义的，有特殊意义的单词。java中所有关键字都是小写的英语单词。比如：public、class、static、void 等。不需要死记硬背，编程过程中逐渐会认识。 三、变量1.字面量（理解）字面量就是数据/数值。生活中每天都会接触到数据，软件其实就是为了解决现实生活当中的问题，处理生活当中的数据，Java程序通过字面量来表示数据。 Java规定： 字符型字面量必须用半角单引号括起来 ，比如’a’,’中‘ 字符串型字面量必须使用半角双引号括起来，比如“中国“ 2.变量（理解）变量是内存中存储数据最基本的单元 变量三要素：数据类型、变量名、存储的值 3.使用变量（掌握）语法格式： ​ 数据类型 变量名； 变量赋值： ​ 变量名= 值； 注意： 在同一个大括号当中不能同时多个同名的变量 变量必须先声明，然后才能使用 4.变量分类（了解）变量根据声明的位置不同，可分为局部变量和成员变量 局部变量：在方法体中声明以及方法的每一个参数都是局部变量 成员变量：在方法体外，类体内声明的变量称为成员变量 成员变量声明时如果使用static关键字修饰的为静态成员变量，简称静态变量 如果没有static关键字修饰的则为实例成员变量，简称实例变量 5.变量作用域变量的作用域就是变量的有效范围。、 口诀：出了大括号就不认识了 四、数据类型1.数据类型概述（理解）数据类型的作用就是决定程序运行阶段该给变量分配多大的内存空间。 数据类型分为基本数据类型和引用数据类型。 基本数据类型分为4类8种： 第1 类：整数型（不带小数的数字）：byte,short,int,long 第2 类：浮点型（带小数的数字）：float,double 第3 类：字符型（文字，单个字符）：char 第4 类：布尔型（真和假）：boolean 字符串属于引用数据类型。 八种基本数据类型详细信息如下：","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"}],"author":"learnqiu"},{"title":"01 - JAVA 及计算机相关入门知识点","slug":"tech-java-01","date":"2021-03-11T10:44:18.000Z","updated":"2021-03-11T11:17:46.817Z","comments":true,"path":"posts/archives/53373.html/","link":"","permalink":"http://example.com/posts/archives/53373.html/","excerpt":"","text":"01 - JAVA 及计算机相关入门知识点 来自 北京动力节点java零基础课程 day-01 课堂笔记 1、计算机结构 计算机包括： * 硬件 - CPU：中央处理器，负责计算机的核心运算，它是计算机的最核心部件，指挥官。 1 + 1 = 2 - 内存：临时存储区域，程序在运行的过程当中，一些数据的临时存储区域。 - 主板：链接各个部件 - 显卡 - 声卡 - 鼠标 - 键盘 - 硬盘【外存】：永久性保存，断电之后再启动，数据仍然存在。 ….. 软件 系统软件 windows系列的 winxp win7…. Linux系列的 Red Hat Fedora SUN Solaris… 应用软件 QQ 百度云管家 Office办公软件 ….. 总结： 应用软件是运行在系统软件当中的，系统软件和底层硬盘交互。 2、Java编程语言作用Java编程语言可以完成应用软件的开发。 3、安装一个功能比记事本强大的文本编辑器可以选择： Sublim EditPlus【我们这里选择】 UtralEdit….. 4、安装软件EditPlus 需要注意： 安装到哪个目录了 不要安装额外的插件 安装路径中最好不要有中文…. 5、显示系统文件类型拓展名windows操作系统默认情况下是不显示文件扩展名的，作为程序员必须将文件的扩展名显示出来： * 计算机 --&gt; 组织 --&gt; 文件夹和搜索选项 --&gt; 查看 --&gt; 隐藏已知文件类型的扩展名【对勾去掉】 6、EditPlus工具的设置​ * windows操作系统当中.txt文件统一采用EditPlus工具打开：设置文件的默认打开程序​ * 去除EditPlus工具的默认备份​ * 设置EditPlus的字体大小​ * 设置EditPlus缩进字符：3​ 工具 –&gt; 首选项 –&gt; ????? 7、windows操作系统当中常用的DOS命令 不使用UI界面，使用DOS命令可以完成所有的操作。 在哪里执行DOS命令？ 在DOS命令窗口中可以执行DOS命令 怎么打开DOS命令窗口呢？ 快捷键：win + r，打开运行窗口 输入cmd回车 查看IP地址： ipconfig ipconfig /all 可以查看更详细的IP信息，这种查看方式可以看到网卡的物理地址。 物理地址具有全球唯一性。是在生产网卡的时候，嵌入的编号。 清屏： cls DOS窗口当中也可以设置字体和屏幕以及文字的颜色。 退出DOS命令窗口 exit 怎么从DOS命令窗口当中复制文本： 任意位置点击鼠标右键–&gt;标记 –&gt; 选择你要复制的文本 –&gt; 点击鼠标右键 （此时已经到剪贴板当中了） 找一个位置粘贴即可。 查看两台计算机之间是否可以正常通信： ping 192.168.27.23 【发送和接收数据包4次】 ping 192.168.27.23 -t 【一直不停的发送和接收数据包】 ping www.baidu.com 登录百度：http://119.75.218.70 强行终止DOS命令窗口中正在运行的程序：ctrl + c 打开DOS命令窗口默认所在的路径是：C:\\Users\\Administrator??? 创建目录：mkdir abc【表示在当前所在目录下新建一个目录，起名abc】 关于目录切换命令：cd cd 命令的语法格式： cd 路径 路径分为： 绝对路径： C:\\Users\\Administrator D:\\用户目录\\收藏夹 F:\\tools\\CamtasiaStudio-v6.00 …… 从硬盘的根路径作为出发点。 相对路径： 从当前所在的位置作为起点的路径。 自动补全： cd e 【然后按tab键，当前所在的目录下所有以e开始的目录自动补全路径， 当这个自动补全的路径不是自己想要的路径，可以继续使用tab键】 回到上级目录：cd .. 【..是一个路径，代表当前路径的上级路径】 cd ../../../ 直接回到根路径：cd \\ 查看当前目录下所有的子文件和子目录： dir 不要把相关重要的资料放到桌面上，因为桌面是属于C盘系统盘。 怎么切换盘符：【不需要使用cd命令】 c: 回车 d: 回车 e: 回车 f: 回车 打开注册表： regedit 8、关于windows操作系统当中常用的快捷键* win + r 打开运行窗口 * win + d 显示桌面 * win + e 打开资源管理器 * win + L 锁屏 * alt + tab 应用之间的切换 9、“通用的”文本编辑快捷键* ctrl + a 全选 * ctrl + c 复制 * ctrl + v 粘贴 * ctrl + s 保存 * ctrl + x 剪切 * ctrl + z 撤销 * ctrl + y 重做 * tab 缩进/多行缩进 * shift + tab 取消缩进 * HOME 回到行首 * END 回到行尾 * shift + home 选中一行 * shift + end 选中一行 * ctrl + shift + 向右或者向左的箭头 选中一个单词 * 鼠标双击：选中一个单词 * 鼠标三击：选中一行 * ctrl + end 回到文件末尾 * ctrl + home 回到文件头 10、什么是JDK？ Java Development Kits Java开发工具箱【Java开发必备】 可以从Oracle的官网上下载。http://www.oracle.com 目前2016-08-30最高版本Java8【Java SE 8u101 / 8u102】 下载JDK的时候需要注意：JDK的版本，不同的操作系统需要安装不同版本的JDK。 11、Java分三大块：1999年 J2SE【Java的标准版本】： 基础，无论是以后走EE还是ME，SE是必须要精通的。 J2SE是SUN公司为java程序员准备的一套“基础类库”，这套基础类库学习之后，可以完成最基本的操作， 例如，文件的读写、线程的控制…. J2EE【Java的企业版本】： 这是SUN公司为程序员专门准备的一套“类库”，这套类库可以协助程序员完成企业级软件的开发 企业级软件：OA办公系统、进销存系统、超市系统……. J2ME【Java的微型版本】 这是SUN公司为java程序员专门准备的另一套“类库”，这套类库可以协助程序员完成微型设备的嵌入式开发， Java最初就是做微型设备嵌入式开发的。 12、Java三大模块改名：2005年2005年，java诞生十周年的时候，以上的三大模块改名了： JavaSE JavaEE JavaME 13、关键术语 JDK【Java开发工具箱】 JRE【Java的运行时环境】 JVM【Java虚拟机】 三者之间的关系： JDK 中包含JRE，JRE中包含JVM。 14、Java语言特性 跨平台/可移植 有一种特殊的机制：JVM Java程序并没有和底层的操作系统直接交互，java程序实际上运行在jvm当中，JVM屏蔽了操作系统之间的差异。 但是有一个前提：不同的操作系统中必须安装不同版本的JVM。 在可移植性方面表现非常好，一次编译，到处运行。 但是为了达到可移植，必须提前在操作系统中安装JRE，JRE有了之后才会有JVM。【JVM不能单独安装】这方面体验不是特别好。 Java号称：开源、免费、跨平台、纯面向对象。 开源：开发源代码，SUN公司编写的java类库的源代码普通程序员能看到。众人拾柴火焰高。这样java程序会很健壮。很少的BUG【漏洞/陷阱】 免费 跨平台：依靠JVM机制【java程序不和操作系统交互，java程序运行在JVM中，JVM和操作系统交互。】不同的操作系统有不同版本的JVM。 面向对象：人类在认识现实世界的时候多数是以面向对象的方式认知的。 简单性： 这里的简单说的是相对于C语言来说的。 例如：C语言当中有指针，C++中多继承 java取消了指针的概念，取消了多继承，只支持单继承。….. java支持多线程 java中还有一种特殊的机制：自动垃圾回收机制。GC机制。 【java运行过程当中有一个“垃圾回收器”一直在守护者。】 …. 15、Java的加载与执行：一个完整的java程序 Java开发的整个生命周期，包括两个重要的阶段，分别是：编译阶段和运行阶段 编译生成的程序被称为：字节码程序。编译生成的文件是：xxx.class文件 编译和运行可以在不同的操作系统中完成。 程序员在xxx.java文件中编写源代码，源代码必须符合java的语法，这些源代码就是高级语言。存放源代码的文件被称为源文件。 过程： 编译期：【在windows环境中完成】 安装JDK，配置环境 在硬盘的某个位置创建一个xxx.java源文件 打开源文件，在该文件当中编写符合java语法的源程序，然后保存。 使用JDK中自带的javac.exe命令对以上的java源程序进行编译。 编译通过：说明语法没有问题 在硬盘上生成一个或者多个字节码文件【xxx.class】 编译失败：说明源程序某个位置不符合java语法格式。 编译的语法格式：打开DOS命令窗口，输入：javac 源文件路径 *注意**： 源文件路径可以是绝对路径，也可以是相对路径。 编译之后，其实java源文件删除不会影响程序的执行。 最好不要将java源文件删除，因为程序最终运行效果不是预期效果的时候，需要 重新修改java源代码，然后进行重新编译生成全新的class字节码文件，再重新运行 字节码程序。 **运行期**：【可以不在windows中完成，可以换一个操作系统，但前提是该操作系统中已经安装java的运行时环境】 打开命令窗口，在命令窗口中使用java.exe命令运行java程序，语法格式： java 类名 注意：java这个命令使用的时候，java命令后面不是文件的路径。必须是一个“类名”。 例如： java Hello java Student java User java Product 以上程序的执行原理： java.exe命令执行会启动：JVM JVM启动之后，马上启动“类加载器-Class Loader” ClassLoader负责去硬盘的“某个位置”上搜索“类名.class”字节码文件。 找不到这个.class文件，一定会出现程序异常现象。 找到了这个.class文件之后将.class文件转换成”二进制”，操作系统可以直接识别二进制，操作系统执行二进制码和底层的硬件平台进行交互。 16、什么是类名？ 假设硬盘上有一个文件，叫做Hello.class，那么类名就叫做：Hello 假设硬盘上有一个文件，叫做Student.class，那么类名就叫做：Student 假设硬盘上有一个文件，叫做User.class，那么类名就叫做：User 假设硬盘上有一个文件，叫做Product.class，那么类名就叫做：Product…..…. 17、开始第一个java程序的开发 JDK下载 JDK安装 只安装了JDK，独立的JRE没有安装 在硬盘的某个位置上新建一个java源文件：HelloWorld.java 在HelloWorld.java文件中编写源代码 打开命令窗口，使用javac命令进行编译： javac 源文件路径 出现以下错误： C:\\Users\\Administrator&gt;javac &#39;javac&#39; 不是内部或外部命令，也不是可运行的程序 或批处理文件。 怎么解决？ 第一种方案：切换到javac.exe文件所在的目录，这个时候使用javac.exe不会出问题，但是这种方式比较麻烦。 第二种方案：配置环境变量path 原理：windows操作系统在查找某个命令的时候是怎么查找的？ * 首先会从当前目录下找这个命令 * 当前目录下不存在这个命令的话，会去环境变量path指定的路径当中查找该命令。 * 还是找不到则出现错误提示信息。 path环境变量隶属于windows操作系统，和java无关，这个环境变量主要用来指定命令的搜索路径。 环境变量怎么配置？ 计算机 –&gt; 点击右键 –&gt; 属性 –&gt; 高级系统设置 –&gt; 环境变量 环境变量配置包括用户级别和系统级别 任何一个环境变量都有变量名和变量值，例如path环境变量： 变量名是:path 值：路径【多个路径之间必须采用分号隔开，而且要求分号必须是半角分号】 path=C:\\Program Files (x86)\\Java\\jdk1.7.0_75\\bin;otherpath;otherpath….. 编译1【绝对路径】：D:\\course\\JavaProjects&gt;javac D:\\course\\JavaProjects\\02-JavaSE\\day01\\HelloWorld.java编译2【相对路径】：D:\\course\\JavaProjects&gt;javac 02-JavaSE\\day01\\HelloWorld.java编译3【相对路径】：D:\\course\\JavaProjects\\02-JavaSE\\day01&gt;javac HelloWorld.java 运行： 必须将路径切换到“D:\\course\\JavaProjects\\02-JavaSE\\day01”目录下 执行：java HelloWorld D:\\course\\JavaProjects\\02-JavaSE\\day01&gt;java HelloWorld Hello World!****","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"}],"author":"learnqiu"},{"title":"枫记","slug":"my-shuoshuo-01","date":"2021-03-09T13:44:11.000Z","updated":"2021-03-09T13:58:28.449Z","comments":true,"path":"posts/archives/40794.html/","link":"","permalink":"http://example.com/posts/archives/40794.html/","excerpt":"","text":"散落枫叶，记录随想雫 突然发现主页live2D封面娘的名字叫shizuku。 好奇查了一下。结果，百度解释如下： 雫，读作しずく（shi zu ku），解作水滴，水滴如雨下，便作“雫”，是一个会意字，从雨部。 如日本电视剧《神の雫》。“雫”读音是shi zu ku ，汉语的读音为xià。 雨下，是个很美的字哎。 ​ 于 2021年3月9日 21点48分","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"随想","slug":"随想","permalink":"http://example.com/tags/%E9%9A%8F%E6%83%B3/"}],"author":"learnqiu"},{"title":"Linux02：常用的基本命令（必掌握）","slug":"tech-kuang-linux-02","date":"2021-03-08T12:46:56.000Z","updated":"2021-03-09T13:23:55.444Z","comments":true,"path":"posts/archives/30405.html/","link":"","permalink":"http://example.com/posts/archives/30405.html/","excerpt":"","text":"常用的基本命令（必掌握）目录管理绝对路径和相对路径我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 /。 其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。 在开始本教程前我们需要先知道什么是绝对路径与相对路径。 绝对路径： 路径的写法，由根目录 / 写起，例如：/usr/share/doc 这个目录。 相对路径： 路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成：cd ../man 这就是相对路径的写法啦！ 处理目录的常用命令接下来我们就来看几个常见的处理目录的命令吧： ls: 列出目录 cd：切换目录 pwd：显示目前的目录 mkdir：创建一个新的目录 rmdir：删除一个空的目录 cp: 复制文件或目录 rm: 移除文件或目录 mv: 移动文件与目录，或修改文件与目录的名称 你可以使用 man [命令] 来查看各个命令的使用文档，如 ：man cp。 ls （列出目录）在Linux系统当中， ls 命令可能是最常被运行的。 语法： [root@www ~]# ls [-aAdfFhilnrRSt] 目录名称 选项与参数： -a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用) -l ：长数据串列出，包含文件的属性与权限等等数据；(常用) 将目录下的所有文件列出来(含属性与隐藏档) [root@www ~]# ls -al ~ cd （切换目录）cd是Change Directory的缩写，这是用来变换工作目录的命令。 语法： cd [相对路径或绝对路径] 测试： # 切换到用户目录下 [root@kuangshen /]# cd home # 使用 mkdir 命令创建 kuangstudy 目录 [root@kuangshen home]# mkdir kuangstudy # 进入 kuangstudy 目录 [root@kuangshen home]# cd kuangstudy # 回到上一级 [root@kuangshen kuangstudy]# cd .. # 回到根目录 [root@kuangshen kuangstudy]# cd / # 表示回到自己的家目录，亦即是 /root 这个目录 [root@kuangshen kuangstudy]# cd ~ 接下来大家多操作几次应该就可以很好的理解 cd 命令的。 pwd ( 显示目前所在的目录 )pwd 是 Print Working Directory 的缩写，也就是显示目前所在目录的命令。 [root@kuangshen kuangstudy]#pwd [-P] 选项与参数：**-P** ：显示出确实的路径，而非使用连接(link) 路径。 测试： # 单纯显示出目前的工作目录 [root@kuangshen ~]# pwd /root # 如果是链接，要显示真实地址，可以使用 -P参数 [root@kuangshen /]# cd bin [root@kuangshen bin]# pwd -P /usr/bin mkdir （创建新目录）如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。 mkdir [-mp] 目录名称 选项与参数： -m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～ -p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！ 测试： # 进入我们用户目录下 [root@kuangshen /]# cd /home # 创建一个 test 文件夹 [root@kuangshen home]# mkdir test # 创建多层级目录 [root@kuangshen home]# mkdir test1/test2/test3/test4 mkdir: cannot create directory ‘test1/test2/test3/test4’: No such file or directory # &lt;== 没办法直接创建此目录啊！ # 加了这个 -p 的选项，可以自行帮你创建多层目录！ [root@kuangshen home]# mkdir -p test1/test2/test3/test4 # 创建权限为 rwx--x--x 的目录。 [root@kuangshen home]# mkdir -m 711 test2 [root@kuangshen home]# ls -l drwxr-xr-x 2 root root 4096 Mar 12 21:55 test drwxr-xr-x 3 root root 4096 Mar 12 21:56 test1 drwx--x--x 2 root root 4096 Mar 12 21:58 test2 rmdir ( 删除空的目录 )语法： rmdir [-p] 目录名称 选项与参数：**-p ：**连同上一级『空的』目录也一起删除 测试： # 看看有多少目录存在？ [root@kuangshen home]# ls -l drwxr-xr-x 2 root root 4096 Mar 12 21:55 test drwxr-xr-x 3 root root 4096 Mar 12 21:56 test1 drwx--x--x 2 root root 4096 Mar 12 21:58 test2 # 可直接删除掉，没问题 [root@kuangshen home]# rmdir test # 因为尚有内容，所以无法删除！ [root@kuangshen home]# rmdir test1 rmdir: failed to remove ‘test1’: Directory not empty # 利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 依次删除。 [root@kuangshen home]# rmdir -p test1/test2/test3/test4 注意：这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录，后面我们会将！ cp ( 复制文件或目录 )语法： [root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination) [root@www ~]# cp [options] source1 source2 source3 .... directory 选项与参数： -a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用) -p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)； -d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身； -r：递归持续复制，用於目录的复制行为；(常用) -f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次； -i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用) -l：进行硬式连结(hard link)的连结档创建，而非复制文件本身。 -s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件； -u：若 destination 比 source 旧才升级 destination ！ 测试： # 找一个有文件的目录，我这里找到 root目录 [root@kuangshen home]# cd /root [root@kuangshen ~]# ls install.sh [root@kuangshen ~]# cd /home # 复制 root目录下的install.sh 到 home目录下 [root@kuangshen home]# cp /root/install.sh /home [root@kuangshen home]# ls install.sh # 再次复制，加上-i参数，增加覆盖询问？ [root@kuangshen home]# cp -i /root/install.sh /home cp: overwrite ‘/home/install.sh’? y # n不覆盖，y为覆盖 rm ( 移除文件或目录 )语法： rm [-fir] 文件或目录 选项与参数： -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息； -i ：互动模式，在删除前会询问使用者是否动作 -r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！ 测试： # 将刚刚在 cp 的实例中创建的 install.sh删除掉！ [root@kuangshen home]# rm -i install.sh rm: remove regular file ‘install.sh’? y # 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！ # 尽量不要在服务器上使用 rm -rf / mv ( 移动文件与目录，或修改名称 )语法： [root@www ~]# mv [-fiu] source destination [root@www ~]# mv [options] source1 source2 source3 .... directory 选项与参数： -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖； -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！ -u ：若目标文件已经存在，且 source 比较新，才会升级 (update) 测试： # 复制一个文件到当前目录 [root@kuangshen home]# cp /root/install.sh /home # 创建一个文件夹 test [root@kuangshen home]# mkdir test # 将复制过来的文件移动到我们创建的目录，并查看 [root@kuangshen home]# mv install.sh test [root@kuangshen home]# ls test [root@kuangshen home]# cd test [root@kuangshen test]# ls install.sh # 将文件夹重命名，然后再次查看！ [root@kuangshen test]# cd .. [root@kuangshen home]# mv test mvtest [root@kuangshen home]# ls mvtest 基本属性看懂文件属性Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。 在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如： 实例中，boot文件的第一个属性用”d”表示。”d”在Linux中代表该文件是一个目录文件。 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等： 当为[ d ]则是目录 当为[ - ]则是文件； 若是[ l ]则表示为链接文档 ( link file )； 若是[ b ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )； 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。 接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。 其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。 每个文件的属性由左边第一部分的10个字符来确定（如下图）： 从左至右用0-9这些数字来表示。 第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。 其中： 第1、4、7位表示读权限，如果用”r”字符表示，则有读权限，如果用”-“字符表示，则没有读权限； 第2、5、8位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限； 第3、6、9位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权限。 对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。 同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。 文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。 因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。 在以上实例中，boot 文件是一个目录文件，属主和属组都为 root。 修改文件属性1、chgrp：更改文件属组chgrp [-R] 属组名 文件名 -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。 2、chown：更改文件属主，也可以同时更改文件属组chown [–R] 属主名 文件名 chown [-R] 属主名：属组名 文件名 3、chmod：更改文件9个属性chmod [-R] xyz 文件或目录 Linux文件属性有两种设置方法，一种是数字，一种是符号。 Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。 先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下： r:4 w:2 x:1 每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为：[-rwxrwx—] 分数则是： owner = rwx = 4+2+1 = 7 group = rwx = 4+2+1 = 7 others= — = 0+0+0 = 0 chmod 770 filename 可以自己下去多进行测试！ 文件内容查看概述Linux系统中使用以下命令来查看文件的内容： cat 由第一行开始显示文件内容 tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！ nl 显示的时候，顺道输出行号！ more 一页一页的显示文件内容 less 与 more 类似，但是比 more 更好的是，他可以往前翻页！ head 只看头几行 tail 只看尾巴几行 你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。 cat 由第一行开始显示文件内容语法： cat [-AbEnTv] 选项与参数： -A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已； -b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！ -E ：将结尾的断行字节 $ 显示出来； -n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同； -T ：将 [tab] 按键以 ^I 显示出来； -v ：列出一些看不出来的特殊字符 测试： # 查看网络配置: 文件地址 /etc/sysconfig/network-scripts/ [root@kuangshen ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0 DEVICE=eth0 BOOTPROTO=dhcp ONBOOT=yes tactac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如： [root@kuangshen ~]# tac /etc/sysconfig/network-scripts/ifcfg-eth0 ONBOOT=yes BOOTPROTO=dhcp DEVICE=eth0 nl 显示行号语法： nl [-bnw] 文件 选项与参数： -b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)； -n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ； -w ：行号栏位的占用的位数。 测试： [root@kuangshen ~]# nl /etc/sysconfig/network-scripts/ifcfg-eth0 1DEVICE=eth0 2BOOTPROTO=dhcp 3ONBOOT=yes more 一页一页翻动在 more 这个程序的运行过程中，你有几个按键可以按的： 空白键 (space)：代表向下翻一页； Enter ：代表向下翻『一行』； /字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字； :f ：立刻显示出档名以及目前显示的行数； q ：代表立刻离开 more ，不再显示该文件内容。 b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。 [root@kuangshen etc]# more /etc/csh.login ....(中间省略).... --More--(28%) # 重点在这一行喔！你的光标也会在这里等待你的命令 less 一页一页翻动，以下实例输出/etc/man.config文件的内容：less运行时可以输入的命令有： 空白键 ：向下翻动一页； [pagedown]：向下翻动一页； [pageup] ：向上翻动一页； /字串 ：向下搜寻『字串』的功能； ?字串 ：向上搜寻『字串』的功能； n ：重复前一个搜寻 (与 / 或 ? 有关！) N ：反向的重复前一个搜寻 (与 / 或 ? 有关！) q ：离开 less 这个程序； [root@kuangshen etc]# more /etc/csh.login ....(中间省略).... : # 这里可以等待你输入命令！ head 取出文件前面几行语法： head [-n number] 文件 选项与参数：**-n** 后面接数字，代表显示几行的意思！ 默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样： [root@kuangshen etc]# head -n 20 /etc/csh.login tail 取出文件后面几行语法： tail [-n number] 文件 选项与参数： -n ：后面接数字，代表显示几行的意思 默认的情况中，显示最后 10 行！若要显示最后 20 行，就得要这样： [root@kuangshen etc]# tail -n 20 /etc/csh.login 拓展：Linux 链接概念Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。 情况下，ln 命令产生硬链接。 硬连接 硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。 硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。 软连接 另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。 测试： [root@kuangshen /]# cd /home [root@kuangshen home]# touch f1 # 创建一个测试文件f1 [root@kuangshen home]# ls f1 [root@kuangshen home]# ln f1 f2 # 创建f1的一个硬连接文件f2 [root@kuangshen home]# ln -s f1 f3 # 创建f1的一个符号连接文件f3 [root@kuangshen home]# ls -li # -i参数显示文件的inode节点信息 397247 -rw-r--r-- 2 root root 0 Mar 13 00:50 f1 397247 -rw-r--r-- 2 root root 0 Mar 13 00:50 f2 397248 lrwxrwxrwx 1 root root 2 Mar 13 00:50 f3 -&gt; f1 从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 397247，然而符号连接文件的 inode 节点不同。 # echo 字符串输出 &gt;&gt; f1 输出到 f1文件 [root@kuangshen home]# echo &quot;I am f1 file&quot; &gt;&gt;f1 [root@kuangshen home]# cat f1 I am f1 file [root@kuangshen home]# cat f2 I am f1 file [root@kuangshen home]# cat f3 I am f1 file [root@kuangshen home]# rm -f f1 [root@kuangshen home]# cat f2 I am f1 file [root@kuangshen home]# cat f3 cat: f3: No such file or directory 通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f1 文件无效； 依此您可以做一些相关的测试，可以得到以下全部结论： 删除符号连接f3,对f1,f2无影响； 删除硬连接f2，对f1,f3也无影响； 删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效； 同时删除原文件f1,硬连接f2，整个文件会真正的被删除。 后面的话，我们就开始学习Vim和用户磁盘相关的命令！从而修改配置！ 本文转载自【狂神说】公众号，仅用于自学。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}],"author":"learnqiu"},{"title":"Linux01：概述及环境搭建","slug":"tech-kuang-linux-01","date":"2021-03-08T11:32:56.000Z","updated":"2021-03-10T13:30:12.115Z","comments":true,"path":"posts/archives/30597.html/","link":"","permalink":"http://example.com/posts/archives/30597.html/","excerpt":"","text":"Linux01：概述及环境搭建入门概述我们为什么要学习Linuxlinux诞生了这么多年，以前还喊着如何能取代windows系统，现在这个口号已经小多了，任何事物发展都有其局限性都有其天花板。就如同在国内再搞一个社交软件取代腾讯一样，想想而已基本不可能，因为用户已经习惯于使用微信交流，不是说技术上实现不了解而是老百姓已经习惯了，想让他们不用，即使他们自己不用亲戚朋友还是要用，没有办法的事情。 用习惯了windows操作系统，再让大家切换到别的操作系统基本上是不可能的事情，改变一个人已经养成的习惯太难。没有办法深入到普通老百姓的生活中，并不意味着linux就没有用武之地了。在服务器端，在开发领域linux倒是越来越受欢迎，很多程序员都觉得不懂点linux都觉得不好意思，linux在开源社区的地位依然岿然不动。 尤其是作为一个后端程序员，是必须要掌握Linux的，因为这都成为了你找工作的基础门槛了，所以不得不学习！ Linux 简介Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。 Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX（可移植操作系统接口） 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。 Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 Linux 发行版Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。 目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。 Linux 应用领域今天各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位，通常服务器使用 LAMP（Linux + Apache + MySQL + PHP）或 LNMP（Linux + Nginx+ MySQL + PHP）组合。 目前 Linux 不仅在家庭与企业中使用，并且在政府中也很受欢迎。 巴西联邦政府由于支持 Linux 而世界闻名。 有新闻报道俄罗斯军队自己制造的 Linux 发布版的，做为 G.H.ost 项目已经取得成果。 印度的 Kerala 联邦计划在向全联邦的高中推广使用 Linux。 中华人民共和国为取得技术独立，在龙芯处理器中排他性地使用 Linux。 在西班牙的一些地区开发了自己的 Linux 发布版，并且在政府与教育领域广泛使用，如 Extremadura 地区的 gnuLinEx 和 Andalusia 地区的 Guadalinex。 葡萄牙同样使用自己的 Linux 发布版 Caixa Mágica，用于 Magalh?es 笔记本电脑和 e-escola 政府软件。 法国和德国同样开始逐步采用 Linux。 Linux vs Windows 环境搭建Linux 的安装，安装步骤比较繁琐，现在其实云服务器挺普遍的，价格也便宜，如果直接不想搭建，也可以直接买一台学习用用！ 安装CentOS（虚拟机安装，耗资源）1、可以通过镜像进行安装！ 2、可以使用我已经制作好的镜像！视频中讲解了该种方式！ 3、安装 VMware 虚拟机软件，然后打开我们的镜像即可使用！ 使用云服务器（推荐）虚拟机安装后占用空间，也会有些卡顿，我们作为程序员其实可以选择购买一台自己的服务器，这样的话更加接近真实线上工作； 1、自行购买云服务器 2、获取服务器的ip地址，重置服务器密码，就可以远程登录了 3、下载 xShell 工具，进行远程连接使用！连接成功效果如下： 注意事项： 如果要打开端口，需要在阿里云的安全组面板中开启对应的出入规则，不然的话会被阿里拦截！ 宝塔面板如果前期不好操作，可以推荐安装宝塔面板，傻瓜式管理服务器 安装教程：https://www.bt.cn/bbs/thread-19376-1-1.html 1、开启对应的端口 2、一键安装 3、安装完毕后会得到远程面板的地址，账号，密码，就可以登录了 4、登录之后就可以可视化的安装环境和部署网站！ 关于域名如果自己的网站想要上线，就一定要购买一个域名然后进行备案； 备案的话需要一些认证和时间，备完完毕后，就可以解析到自己的网站了，这个时候就可以使用域名来进行服务器的访问！ 走近Linux系统开机登录开机会启动许多程序。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。 开机成功后，它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份，密码是不显示的，输完回车即可！ 一般来说，用户的登录方式有三种： 命令行登录 ssh登录 图形界面登录 最高权限账户为 root，可以操作一切！ 关机在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。 关机指令为：shutdown ； sync # 将数据由内存同步到硬盘中。 shutdown # 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机： shutdown –h 10 # 这个命令告诉大家，计算机将在10分钟后关机 shutdown –h now # 立马关机 shutdown –h 20:25 # 系统会在今天20:25关机 shutdown –h +10 # 十分钟后关机 shutdown –r now # 系统立马重启 shutdown –r +10 # 系统十分钟后重启 reboot # 就是重启，等同于 shutdown –r now halt # 关闭系统，等同于shutdown –h now 和 poweroff 最后总结一下，不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中。 系统目录结构登录系统后，在当前命令窗口下输入命令： ls / 你会看到如下图所示： 树状目录结构：（Linux的一切资源都挂载在这个 / 根节点下） 以下是对这些目录的解释： /bin：bin是Binary的缩写, 这个目录存放着最经常使用的命令。 /boot： 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 /dev ： dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 /etc： 这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。 /lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 /mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。 /opt：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 /proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。 /root：该目录为系统管理员，也称作超级权限者的用户主目录。 /sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /srv：该目录存放一些服务启动之后需要提取的数据。 /sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。 /tmp：这个目录是用来存放一些临时文件的。 /usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。 /usr/bin： 系统用户使用的应用程序。 /usr/sbin： 超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src： 内核源代码默认的放置目录。 /var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 /run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。 本文转载自【狂神说】公众号，仅用于自学。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}],"author":"learnqiu"},{"title":"tech-juc-01","slug":"tech-juc-01","date":"2021-03-05T11:13:55.000Z","updated":"2021-03-09T12:56:31.279Z","comments":true,"path":"posts/archives/31029.html/","link":"","permalink":"http://example.com/posts/archives/31029.html/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"learnqiu"},{"title":"tech-sql-02","slug":"tech-sql-02","date":"2021-01-16T06:20:57.000Z","updated":"2021-03-09T12:56:31.288Z","comments":true,"path":"posts/archives/42373.html/","link":"","permalink":"http://example.com/posts/archives/42373.html/","excerpt":"","text":"数据库三范式第一范式：每个表都要有主键，每个字段原子不可再分 第二范式：其他字段只依赖于表的主键，不产生复合依赖 -&gt; 多对多，三张表，关系表两个外键 第三范式：不产生传递依赖 -&gt; 一对多，两张表，多的表加外键 实际项目中，有时会牺牲空间换时间 事务特性原子性，一致性，隔离性，持久性 事务的隔离级别： 第一级别：读未提交 第二级别：读已提交 oracle 第三级别：可重复读 mysql 第四级别：序列化读 索引原理，数据库采用索引查询时，首先根据查询值找到对应的索引分区，从而定位到值的物理位置，最后通过物理位置查找到对应数据","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"learnqiu"},{"title":"","slug":"tech-sql-01","date":"2021-01-11T05:19:51.000Z","updated":"2021-01-14T11:12:39.197Z","comments":true,"path":"posts/archives/1.html/","link":"","permalink":"http://example.com/posts/archives/1.html/","excerpt":"","text":"34道SQL作业题表结构员工表 部门表 薪资等级表 – 1、取得每个部门最高薪水的人员名称– STEP1 取得每个部门最高薪水（按照部门编号编组，找出每一组最大值） SELECT DEPTNO,MAX(SAL) MAXSAL FROM EMP GROUP BY DEPTNO; – STEP2 与人员表连接，连接条件：where t.DEPTNO = e.DEPTNO AND t.MAXSAL = e.SAL SELECT e.ename,e.sal,e.DEPTNO from (SELECT DEPTNO,MAX(SAL) MAXSAL FROM EMP GROUP BY DEPTNO) t join EMP e on t.DEPTNO = e.DEPTNO AND t.MAXSAL = e.SAL; – STEP2 与人员表连接，连接条件：where t.DEPTNO = e.DEPTNO AND t.MAXSAL = e.SAL SELECT e.ename,e.sal,e.DEPTNO from (SELECT DEPTNO,MAX(SAL) MAXSAL FROM EMP GROUP BY DEPTNO) t join EMP e on t.DEPTNO = e.DEPTNO AND t.MAXSAL = e.SAL; – 2、哪些人的薪水在部门的平均薪水之上– STEP1 找出每个部门平均薪水 SELECT DEPTNO,AVG(SAL) AVGSAL FROM EMP GROUP BY DEPTNO; – STEP2 与人员表连接，连接条件：where t.DEPTNO = e.DEPTNO AND t.AVGSAL &lt; e.SAL SELECT e.ename,e.sal,e.DEPTNO,t.AVGSAL from (SELECT DEPTNO,AVG(SAL) AVGSAL FROM EMP GROUP BY DEPTNO) t join EMP e on t.DEPTNO = e.DEPTNO AND t.AVGSAL &lt; e.SAL; – 3、取得部门中（所有人的）平均的薪水等级– STEP1 取得部门中（所有人的）的薪水等级– 与等级表连接，连接条件：where e.SAL &gt;= s.LOSAL AND e.SAL &lt;= s.HISAL– 也可使用连接条件：e.SAL BETWEEN s.LOSAL AND s.HISAL SELECT s.GRADE,e.* from EMP e join SALGRADE s on e.SAL &gt;= s.LOSAL AND e.SAL &lt;= s.HISAL; – STEP2 取得部门中（所有人的）平均的薪水等级 SELECT t.DEPTNO,AVG(t.GRADE) AVGGRADE FROM (SELECT s.GRADE,e.* from EMP e join SALGRADE s on e.SAL &gt;= s.LOSAL AND e.SAL &lt;= s.HISAL)t group by t.DEPTNO; – STEP2 取得部门中（所有人的）平均的薪水等级 SELECT t.DEPTNO,AVG(t.GRADE) AVGGRADE FROM (SELECT s.GRADE,e.* from EMP e join SALGRADE s on e.SAL &gt;= s.LOSAL AND e.SAL &lt;= s.HISAL)t group by t.DEPTNO; – STEP2 直接使用group by和分组函数 不使用临时表 SELECT DEPTNO,AVG(GRADE) AVGGRADE FROM EMP e join SALGRADE s on e.SAL BETWEEN s.LOSAL AND s.HISAL group by DEPTNO; ​ ​ – 4、不准用组函数（Max），取得最高薪水– 方案一 采用SAL排序,取第一行rownum=1 SELECT sal from (SELECT * from emp order by SAL desc) t where rownum=1; – 方案二 表的自连接 注意思路 select sal from emp where sal not in (SELECT distinct a.sal from emp a join emp b on a.sal &lt; b.sal); – 方案三 MAX SELECT MAX(sal) from emp; – 5、取得平均薪水最高的部门的部门编号– 方案一：降序取第一个 SELECT * FROM (SELECT * from (SELECT DEPTNO,AVG(SAL) AVGSAL FROM EMP GROUP BY DEPTNO) t ORDER BY AVGSAL DESC) m where rownum = 1; – 方案二：MAX 注意having后面跟着AVG(SAL)，mysql可以直接跟AVGSAL SELECT DEPTNO,AVG(SAL) AVGSAL FROM EMP GROUP BY DEPTNO HAVING AVG(SAL) = (SELECT MAX(AVGSAL) from (SELECT DEPTNO,AVG(SAL) AVGSAL FROM EMP GROUP BY DEPTNO)); – 6、取得平均薪水最高的部门的部门名称SELECT DNAME from DEPT where DEPTNO = (SELECT DEPTNO FROM (SELECT * from (SELECT DEPTNO,AVG(SAL) AVGSAL FROM EMP GROUP BY DEPTNO) t ORDER BY AVGSAL DESC) m where rownum = 1); – 7、求平均薪水的等级最低的部门的部门名称– 错误解法 SELECT DNAME from DEPT where DEPTNO = (SELECT DEPTNO FROM (SELECT * from (SELECT DEPTNO,AVG(SAL) AVGSAL FROM EMP GROUP BY DEPTNO) t ORDER BY AVGSAL ) m where rownum = 1); – 注意平均薪水最低，平均薪水等级一定最低，但是平均薪水不是最低，平均薪水等级也有可能是最低– 所以平均薪水等级最低的有可能是多个，不能通过降序取第一个部门编号，而是取最低等级拿等级做筛选– STEP1 取得所有部门平均薪水的等级 SELECT m.*,t.* FROM (SELECT * from (SELECT DEPTNO,AVG(SAL) AVGSAL FROM EMP GROUP BY DEPTNO) t ORDER BY AVGSAL ) m JOIN SALGRADE t ON m.AVGSAL BETWEEN t.LOSAL AND t.HISAL; – STEP2 取得最低的平均薪水的等级 SELECT MIN(GRADE) FROM (SELECT * from (SELECT DEPTNO,AVG(SAL) AVGSAL FROM EMP GROUP BY DEPTNO) t ORDER BY AVGSAL ) m JOIN SALGRADE t ON m.AVGSAL BETWEEN t.LOSAL AND t.HISAL; – STEP3 取得平均薪水的等级最低的部门的部门名称 SELECT DNAME from DEPT where DEPTNO = (SELECT DEPTNO FROM (SELECT * from (SELECT DEPTNO,AVG(SAL) AVGSAL FROM EMP GROUP BY DEPTNO) t ORDER BY AVGSAL ) m JOIN SALGRADE t ON m.AVGSAL BETWEEN t.LOSAL AND t.HISAL where GRADE = (SELECT MIN(GRADE) FROM (SELECT * from (SELECT DEPTNO,AVG(SAL) AVGSAL FROM EMP GROUP BY DEPTNO) t ORDER BY AVGSAL ) m JOIN SALGRADE t ON m.AVGSAL BETWEEN t.LOSAL AND t.HISAL)); – 8、取得比普通员工(员工代码没有在mgr字段上出现的)的最高薪水还要高的领导人姓名– STEP1 取得普通员工 SELECT distinct MGR FROM EMP WHERE MGR IS not null; – STEP2 取得普通员工最高薪水 not in 在使用时后面括号中的结果要排除null SELECT MAX(SAL) MAXSAL from EMP where EMPNO not in (SELECT distinct MGR FROM EMP WHERE MGR IS not null); – STEP3 取得比普通员工(员工代码没有在mgr字段上出现的)的最高薪水还要高的领导人姓名 SELECT ENAME from EMP where EMPNO in (SELECT distinct MGR FROM EMP WHERE MGR IS not null) and SAL &gt; (SELECT MAX(SAL) MAXSAL from EMP where EMPNO not in (SELECT distinct MGR FROM EMP WHERE MGR IS not null)); – 9、取得薪水最高的前五名员工SELECT * from (SELECT * from EMP ORDER BY SAL DESC) t WHERE rownum &lt;6; – 10、取得薪水最高的第六到第十名员工 mysql使用 limmit 5,5SELECT * from (SELECT * from (SELECT * from (SELECT * from EMP ORDER BY SAL DESC) t WHERE rownum &lt;11) tt ORDER BY SAL) ttt WHERE rownum &lt;6; – 11、取得最后入职的5名员工SELECT * from (SELECT * from EMP ORDER BY HIREDATE DESC)WHERE rownum &lt;6; – 12、取得每个薪水等级有多少员工– STEP1 获得员工等级 SELECT s.GRADE,e.* from EMP e join SALGRADE s on e.SAL &gt;= s.LOSAL AND e.SAL &lt;= s.HISAL; – STEP2 按员工等级分组计数 ​ SELECT t.GRADE,COUNT(*) FROM (SELECT s.GRADE,e.* from EMP e join SALGRADE s on e.SAL &gt;= s.LOSAL AND e.SAL &lt;= s.HISAL)t group by t.GRADE; ​ – 13、面试题– 14、列出所有员工及领导的姓名– 错误解法:使用join后，会缺少king的信息 SELECT A.ENAME,B.ENAME FROM EMP A JOIN EMP B ON A.MGR = B.EMPNO; – 正确解法:使用left join后，会保证左边表格的信息的完整性，如果未匹配到信息则以null显示,这样KING的信息正常显示 SELECT A.ENAME,B.ENAME FROM EMP A LEFT JOIN EMP B ON A.MGR = B.EMPNO; – 15.列出受雇日期早于其直接上级的所有员工的编号,姓名,部门名称– 注意此时使用JOIN ,join可以连用 SELECT A.ENAME 员工,B.ENAME 领导,d.DNAME 部门名称,a.HIREDATE 员工受雇日期,b.HIREDATE 领导受雇日期 FROM EMP A JOIN EMP B ON A.MGR = B.EMPNO JOIN DEPT d ON a.deptno = d.deptno where A.HIREDATE &lt; B.HIREDATE; – 16、列出部门名称和这些部门的员工信息,同时列出那些没有员工的部门SELECT a.DNAME,b.* FROM DEPT a left join EMP b on a.DEPTNO = b.DEPTNO; ​ – 17、列出至少有5个员工的所有部门– SETP1 按DEPTNO分组计数 SELECT DEPTNO,count(*) from emp group by DEPTNO; – SETP2 获取至少5个员工的所有部门 SELECT DEPTNO,count(*) from emp group by DEPTNO having count(*)&gt;4; – 18、列出薪金比”SMITH”多的所有员工信息– SETP1 获取”SMITH”的薪金 SELECT SAL from emp WHERE ENAME = &#39;SMITH&#39;; – STEP2 列出薪金比”SMITH”多的所有员工信息 SELECT * from emp WHERE SAL &gt; (SELECT SAL from emp WHERE ENAME = &#39;SMITH&#39;); – 19、列出所有”CLERK”(办事员)的姓名及其部门名称,部门的人数– 列出所有”CLERK”(办事员)姓名及其部门名称,部门的人数 SELECT ENAME,DNAME,ENUM from emp e join dept d on e.DEPTNO = d.DEPTNO JOIN (SELECT DEPTNO,count(*) ENUM from emp group by DEPTNO) t ON e.DEPTNO = t.DEPTNO WHERE JOB = &#39;CLERK&#39;; – 20、列出最低薪金大于1500的各种工作及从事此工作的全部雇员人数– SETP1 获取各种工作的最低薪金 SELECT JOB,MIN(SAL) MINSAL FROM EMP GROUP BY JOB; – SETP2 列出最低薪金大于1500的各种工作 SELECT JOB MINSAL FROM EMP GROUP BY JOB HAVING MIN(SAL) &gt;1500; – SETP2 列出最低薪金大于1500的各种工作及从事此工作的全部雇员人数 按job分组计数后筛选 SELECT JOB,COUNT(*) MINSAL FROM EMP GROUP BY JOB HAVING JOB IN (SELECT JOB MINSAL FROM EMP GROUP BY JOB HAVING MIN(SAL) &gt;1500); – 21、列出在部门”SALES”&lt;销售部&gt;工作的员工的姓名,假定不知道销售部的部门编号SELECT ename FROM EMP e join DEPT d on e.DEPTNO = d.DEPTNO where dname = &#39;SALES&#39;; – 22、列出薪金高于公司平均薪金的所有员工,所在部门,上级领导,雇员的工资等级– SETP1 获取公司平均薪金 SELECT avg(Sal) from emp; – SETP2 连接员工，部门，salgrade表 SELECT * from emp a left join emp b on a.mgr = b.EMPNO join DEPT d on a.DEPTNO = d.DNAME join SALGRADE s on a.sal between s.LOSAL and s.HISAL; – SETP3 获取薪金高于公司平均薪金的所有员工 SELECT a.ENAME 员工,d.dname 部门,a.ENAME 领导,s.GRADE 等级 from emp a left join emp b on a.mgr = b.EMPNO join DEPT d on a.DEPTNO = d.DEPTNO join SALGRADE s on a.sal between s.LOSAL and s.HISAL where a.Sal &gt; (SELECT avg(Sal) from emp); – 23、列出与”SCOTT”从事相同工作的所有员工及部门名称– SETP1 获取”SCOTT”从事的工作 SELECT JOB FROM EMP WHERE ENAME = &#39;SCOTT&#39;; – SETP2 连接人员，部门表 SELECT * FROM EMP e left join dept d on e.DEPTNO = d.DEPTNO; – SETP3 列出与”SCOTT”从事相同工作的所有员工及部门名称 SELECT * FROM EMP e left join dept d on e.DEPTNO = d.DEPTNO where JOB = (SELECT JOB FROM EMP WHERE ENAME = &#39;SCOTT&#39;); – 24、列出薪金等于部门30中员工的薪金的其他员工的姓名和薪金– SETP1 获取30部门员工和其他部门员工 SELECT * FROM EMP where DEPTNO != &#39;30&#39;; SELECT * FROM EMP where DEPTNO = &#39;30&#39;; – SETP2 列出薪金等于部门30中员工的薪金的其他员工的姓名和薪金 SELECT * FROM (SELECT * FROM EMP where DEPTNO != &#39;30&#39;) a join (SELECT * FROM EMP where DEPTNO = &#39;30&#39;) b on a.Sal = b.Sal; – 25、列出薪金高于在部门30工作的所有员工的薪金的员工姓名和薪金.部门名称– SETP1 获取30部门员工的最高薪资 SELECT MAX(SAL) FROM EMP where DEPTNO = &#39;30&#39;; – SETP2 列出薪金高于在部门30工作的所有员工的薪金的员工姓名和薪金.部门名称 SELECT ENAME,SAL,DNAME FROM EMP E JOIN DEPT D ON E.DEPTNO = D.DEPTNO WHERE SAL &gt; (SELECT MAX(SAL) FROM EMP where DEPTNO = &#39;30&#39;); – 26、列出在每个部门工作的员工数量,平均工资和平均服务期限– SETP1 连接员工，SALGRADE SELECT * from emp a join SALGRADE s on a.sal between s.LOSAL and s.HISAL; – SETP2 分组并计数 SELECT a.DEPTNO 部门编号,count(*) 员工数,avg(a.sal) 平均工资,avg(a.COMM) 平均服务期限 from emp a join SALGRADE s on a.sal between s.LOSAL and s.HISAL group by a.DEPTNO; – 27、列出所有员工的姓名、部门名称和工资select e.ename 员工姓名,d.dname 部门名称,e.sal 工资 from emp e join dept d on e.DEPTNO = d.DEPTNO; – 28、列出所有部门的详细信息和人数SELECT d.*,e.num 人数 from DEPT d join (SELECT DEPTNO,count(*) num from emp group by DEPTNO) e on e.DEPTNO = d.DEPTNO; – 29、列出各种工作的最低工资及从事此工作的雇员姓名– SETP1 列出各种工作的最低工资 SELECT job,min(sal) minsal from emp group by job; – SETP2 上表作为临时表与员工表连接 SELECT e.job,minsal,e.ename,e.sal FROM EMP e join (SELECT job,min(sal) minsal from emp group by job)a on e.job = a.job where sal = minsal; – 30、列出各个部门的MANAGER(领导)的最低薪金– SETP1 列出各个部门的MANAGER SELECT distinct b.ename from emp a join emp b on a.MGR = b.EMPNO; – SETP2 列出各个部门的MANAGER的最低薪金 SELECT min(sal) from emp where ename in (SELECT distinct b.ename from emp a join emp b on a.MGR = b.EMPNO); – 31、列出所有员工的年工资,按年薪从低到高排序SELECT ename,sal*12 from emp order by sal; – 32、求出员工领导的薪水超过3000的员工名称与领导名称SELECT a.ename,b.ename,b.sal from emp a join emp b on a.MGR = b.EMPNO where b.sal &gt;=3000; – 33、求出部门名称中,带’S’字符的部门员工的工资合计、部门人数– SETP1 求出部门名称中,带’S’字符的部门 SELECT deptno from dept where DNAME like &#39;%S%&#39;; – SETP2 求出部门名称中,带’S’字符的部门员工的工资合计、部门人数 SELECT deptno,count(*),sum(sal) from emp where deptno in (SELECT deptno from dept where DNAME like &#39;%S%&#39;) group by DEPTNO; – 34、给任职日期超过30年的员工加薪10%update emp set sal = sal*1.1 where get_year(to_date(sysdate,&#39;yyyy-MM-dd HH24:mi:ss&#39;),to_date(HIREDATE,&#39;yyyy-MM-dd&#39;)) &gt; 30; – 方案二 表的自连接 注意思路 select sal from emp where sal not in (SELECT distinct a.sal from emp a join emp b on a.sal &lt; b.sal); – 方案三 MAX SELECT MAX(sal) from emp;","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"},{"name":"ORACLE","slug":"ORACLE","permalink":"http://example.com/tags/ORACLE/"}],"author":"learnqiu"},{"title":"冷秋 | 书摘","slug":"mind-book-02","date":"2021-01-08T12:57:29.000Z","updated":"2021-01-08T13:11:11.168Z","comments":true,"path":"posts/archives/44545.html/","link":"","permalink":"http://example.com/posts/archives/44545.html/","excerpt":"","text":"冷秋 | 书摘一​ “假如一间铁屋子，是绝无窗户而万难破毁的，里面有许多熟睡的人们，不久都要闷死了，然而是从昏睡入死灭，并不感到就死的悲哀。现在你大嚷起来，惊起了较为清醒的几个人，使这不幸的少数者来受无可挽救的临终的苦楚，你倒以为对得起他们么？” ​ “然而几个人既然起来，你不能说决没有毁坏这铁屋的希望。” ​ – 鲁迅《呐喊》 ​ 二零二一年一月八日 摘 若不呐喊，只得在沉睡中灭亡；而惊醒，才是少数人希望的曙光。 ​ –冷秋 | 给困于铁屋子中熟睡的自己的一声呐喊","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"learnqiu"},{"title":"致2020","slug":"mind-movie-02","date":"2021-01-04T12:01:55.000Z","updated":"2021-01-04T12:20:18.416Z","comments":true,"path":"posts/archives/41181.html/","link":"","permalink":"http://example.com/posts/archives/41181.html/","excerpt":"","text":"致2020谨以下面的视频致我已经过去的2020 健康快乐，顺利毕业！","categories":[{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"剧集","slug":"剧集","permalink":"http://example.com/tags/%E5%89%A7%E9%9B%86/"}],"author":"learnqiu"},{"title":"转载：将hexo博客部署到CentOS个人云服务器","slug":"tech-hexo-05","date":"2021-01-04T11:43:29.000Z","updated":"2021-01-04T12:15:41.696Z","comments":true,"path":"posts/archives/48313.html/","link":"","permalink":"http://example.com/posts/archives/48313.html/","excerpt":"","text":"转载：将hexo博客部署到CentOS个人云服务器转载来源:HEXO 部署到云服务器详细指南 我是按照下面内容进行操作的，最终成功部署到了个人云服务器上。 原文如下： 前段时间薅羊毛了腾讯云的羊毛，花了360软妹纸买了6年的云服务。。。打算把以前托管在github上的hexo部署到个人云服务器。折腾了良久，便有了以下的文章。 一、环境安装1.1 node js 安装yum install gcc-c++ make yum -y install nodejs 验证： node -v npm -v 1.2 安装git、nginxGit 用于版本管理和部署，Nginx 用于静态博客托管。 yum install git nginx -y 1.3 安装hexo我们使用 Node.js 的包管理器 npm 安装 hexo-cli 和 hexo-server npm install hexo-cli hexo-server -g hexo-cli 是 Hexo 的命令行工具，可用于快速新建、发布、部署博客；hexo-server 是 Hexo 的内建服务器，可用于部署前的预览和测试。-g 选项，表示全局安装。 验证 hexo 二、创建git环境参考地址 2.1 在云服务器上创建一个 GIT 用户，用来运行 GIT 服务 创建用户：adduser git 设置密码：passwd git 2.2 创建证书 切换到git用户：su git 创建.ssh目录：mkdir .ssh &amp;&amp; chmod 700 .ssh 然后在云服务创建authorized_keys公钥保存文件：touch .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys __ tip: __ 公钥保存文件authorized_keys是一行添加一个 2.3 创建git仓库目录创建一个名为blog的git仓库 mkdir /var/repo cd /var/repo git init --bare blog.git 2.4 配置 GIT HOOKSvim /var/repo/blog.git/hooks/post-receive 添加 #!/bin/sh git --work-tree=/var/www/hexo --git-dir=/var/repo/blog.git checkout -f 然后保存退出，并设置权限 chmod +x /var/repo/blog.git/hooks/post-receive 2.5 改变 BLOG.GIT 目录的拥有者为 GIT 用户chown -R git:git blog.git 2.6 创建静态文件目录并将2.3步骤生成的git仓库链接到静态文件目录下 创建静态文件目录（文章网页）：mkdir /var/www/hexo 链接git仓库：chown -R git:git /var/www/hexo 配置权限：chmod -R 755 /var/www/hexo 这样git仓库更新便会自动同步到hexo目录下 2.7、为了安全考虑，禁用GIT用户的SHELL 登录权限配置（下面两个步骤非常重要，否则客户端总是提示密码错误！！！） 首先你必须确保 git-shell 已存在于 /etc/shells 文件中 使用命令which git-shell判断系统是否安装了git-shell。如果已经安装，则返回git-shell的安装目录，如：/usr/bin/git-shell；如果未安装则需要安装git-shell命令，安装命令：yum install git 判断shells文件是否存在，判断命令：cat /etc/shells 如果文件不存在或没有 /usr/bin/git-shell ，则需要使用vim增加这个路径： sudo vim /etc/shells ，在最后一行添加git-shell路径 # /etc/shells: valid login shells /bin/sh /bin/dash /bin/bash /bin/rbash /usr/bin/tmux /usr/bin/screen /usr/bin/git-shell # 添加你的git-shell ``` 现在你可以使用 chsh 命令修改任一系统用户的shell权限了 现在我们修改第一步中创建的git用户的登录权限，禁止git用户使用shell权限： 终端中输入sudo chsh git [图片上传失败…(image-86e8df-1521642804894)] 然后在Login Shell [/bin/bash]: 后输入git-shell路径/usr/bin/git-shell 修改完成后验证： vim /etc/passwd找到类似git:x:1000:1000:,,,:/home/git:/usr/bin/git-shell，看看git用户是否是以git-shell结尾 这样，git用户就只能使用SSH连接对Git仓库进行推送和拉取操作，而不能登录机器并取得普通shell命令 2.8 测试当上述步骤都完成后，我们就可以测试下git服务器是否部署成功，最简单的方法便是使用clone来校验 用户电脑（window or mac）git客户端执行clone操作git clone git@服务器ip:/var/repo/blog.git 当出现下面这种框，然后输入我们在第一步时创建git这个用户的密码就能成功clone了。 ​ git_server 或 ​ git_server 如果clone成功，表示git服务器搭建成功 三、hexo配置打开hexo博客目录，编辑_config.yml文件 修改repository为： deploy: type: git repository: git@ip或域名:/var/repo/blog.git branch: master 然后执行hexo g -d将文件上传到你部署的服务器上，如果上传成功，将如下图所示： article_upload_finish.png 四、nginx配置最后，为了能让浏览器能直接访问静态页面，需要使用nginx将端口或域名指向hexo静态文件目录 4.1 修改 NGINX 的 DEFAULT 设置 ubuntu vim /etc/nginx/sites-available/default centos vim /etc/nginx/conf.d/blog.conf 注意：不同版本的nginx或系统，nginx的配置文件不一定相同，根据具体情况来修改配置 4.2 将其中的 ROOT 指令指向 /var/www/hexo 目录（也就是GIT钩子目录）server &#123; listen 80; listen [::]:80; root /var/www/hexo; # 修改的地方 server_name laoyuyu.me www.laoyuyu.me; # 如果需要改域名访问，修改server_name 为域名便可 location / &#123; # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; &#125; &#125; 4.3 最后重启服务，让NGINX生效service nginx restart 4.4 nginx 常见错误我在配置完Nginx后，启动的时候总是无法正常访问到我的web应用，查看日志文件（/var/log/nginx/error.log）后发现： connect() to 127.0.0.1:8080 failed (13: Permission denied) 从这个错误信息中可以看出是访问权限的问题，解决办法如下： vi /etc/nginx/nginx.conf #user nginx; user root; 其实就是将nginx的用户修改为root用户即可，当然也可以为nginx用户增加相应的权限。 我部署在虚拟机上的个人网站","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo博客搭建","slug":"hexo博客搭建","permalink":"http://example.com/tags/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"author":"learnqiu"},{"title":"晚归记-冷秋的第一个Vlog","slug":"video-vlog-01","date":"2020-12-29T08:28:49.000Z","updated":"2021-01-04T12:14:28.014Z","comments":true,"path":"posts/archives/36200.html/","link":"","permalink":"http://example.com/posts/archives/36200.html/","excerpt":"","text":"晚归记-冷秋的第一个Vlog","categories":[{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"剧集","slug":"剧集","permalink":"http://example.com/tags/%E5%89%A7%E9%9B%86/"}],"author":"learnqiu"},{"title":"2021 考研加油","slug":"mind-day-01","date":"2020-12-26T14:54:49.000Z","updated":"2020-12-26T15:10:53.860Z","comments":true,"path":"posts/archives/45480.html/","link":"","permalink":"http://example.com/posts/archives/45480.html/","excerpt":"","text":"2021 考研加油今天， 是无数个梦想的盛会， 因为， 有377万人在风中起舞。 加油考研人！","categories":[{"name":"随想","slug":"随想","permalink":"http://example.com/categories/%E9%9A%8F%E6%83%B3/"}],"tags":[{"name":"随想","slug":"随想","permalink":"http://example.com/tags/%E9%9A%8F%E6%83%B3/"}],"author":"learnqiu"},{"title":"对hexo-sakura主题的鼠标指针图案进行自定义","slug":"tech-hexo-04","date":"2020-12-25T09:30:04.000Z","updated":"2020-12-25T09:51:54.212Z","comments":true,"path":"posts/archives/31864.html/","link":"","permalink":"http://example.com/posts/archives/31864.html/","excerpt":"","text":"对hexo-sakura主题的鼠标指针图案进行自定义前言本文主要介绍如何自定义hexo-sakura主题的鼠标指针图案 实现原理首先hexo-sakura主题自带的鼠标指针方案是黑猫的指针，首先我们找到定义鼠标样式的位置 打开博客根目录/themes/source/css/style.css文件，用ctrl+F 全局搜索“img/cursor/”(第一次可以这样搜索)或者”.cur“（修改后可以用这个定位） 通过查看发现，网站用的图标样式都是调用的cur图标的cdn文件链接 要对光标进行自定义，只用将对于位置的cur文件进行替换就可以了 实现步骤1.网络下载静态光标文件（.cur）,经过测试不支持动态光标文件（.ani） 这里提供我在网上找到的静态光标文件（链接：https://pan.baidu.com/s/1TC8EHD2Wb6CLZv6R0wAvqw 提取码：tvnb ），需要的可以自行下载 2.将需要使用的光标文件上传到你的图床 3.将style.css文件中的链接换成你需要使用的cur文件链接 如： 4.这里说明一下，自定义鼠标光标有两种方式： 方式一：深度定义。实现不同场景展示不同鼠标图案。这种方式需要将style.css文件中的所有cur链接进行自定义替换，替换方法见步骤3。 方式二：全局定义，即所有场景只使用一种鼠标图案。这种方式步骤如下： ​ 1.将styles.css中所有”.cur“图床链接处所在的cursor:…这行删除 ​ 2.在css中加入如下代码，其中链接填你需要全局定义的鼠标光标链接： *&#123; cursor: url(https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/cursor/normal.cur),auto &#125; 实现效果见本站的鼠标光标样式","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo博客美化","slug":"hexo博客美化","permalink":"http://example.com/tags/hexo%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"}],"author":"learnqiu"},{"title":"hexo博客优化记录","slug":"tech-hexo-03","date":"2020-12-23T13:49:07.000Z","updated":"2020-12-29T10:08:00.027Z","comments":true,"path":"posts/archives/48697.html/","link":"","permalink":"http://example.com/posts/archives/48697.html/","excerpt":"","text":"hexo博客优化记录前言本文用于记录本博客优化相关内容。 1.Hexo Sakura为每个帖子创建一个唯一链接参考文献：Hexo Next为每个帖子创建一个唯一链接 安装如下插件 npm install hexo-abbrlink --save 配置 在hexo根目录下config.yml的配置文件设置permalink为 permalink: posts/archives/:abbrlink.html/ 效果 若不能正常生成，执行 hexo clean 2.Hexo Sakura实现文章插入b站视频插件前言由于b站视频的av号不够用了，现在很多视频都是bv号，sakura自带的hexo-tag-bili只支持av号的视频，插件也没有进行更新，下面说一下怎么实现插入b站的视频插件。 实现方法b站视频的分享按钮有生成分享插件代码的功能 初始插件代码为: &lt;iframe src=&quot;//player.bilibili.com/player.html?aid=330803387&amp;bvid=BV1KA411x7YS&amp;cid=272300009&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt; 但是这个插件的尺寸比较小，我们需要对其大小进行定义 在博客根目录\\themes\\Sakura\\source\\css\\style.css文件中加入以下代码: /*哔哩哔哩视频适配 */ .bilibili &#123; position: relative; width: 100%; &#125; @media only screen and (max-width: 767px) &#123; .bilibili &#123;height: 15em;max-width: 25em;&#125; &#125; @media only screen and (min-width: 768px) and (max-width: 991px) &#123; .bilibili &#123;height: 20em;max-width: 30em;&#125; &#125; @media only screen and (min-width: 992px) and (max-width: 1199px) &#123; .bilibili &#123;height: 30em;max-width: 40em;&#125; &#125; @media only screen and (min-width: 1200px) &#123; .bilibili &#123;height: 40em;max-width: 50em;&#125; &#125; 这样的话，在插件中使用这个css样式就可以了 &lt;iframe class=&quot;bilibili&quot; src=&quot;//player.bilibili.com/player.html?aid=330803387&amp;bvid=BV1KA411x7YS&amp;cid=272300009&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt; 使用步骤1.前往b站视频，点击分享按钮，复制插件代码 2.在插件代码中加入 class=&quot;bilibili&quot; 调用css样式 实现效果 案例链接","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo博客美化","slug":"hexo博客美化","permalink":"http://example.com/tags/hexo%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"}],"author":"learnqiu"},{"title":"hexo博客踩坑记录","slug":"tech-hexo-02","date":"2020-12-23T11:22:01.000Z","updated":"2021-01-04T12:00:50.184Z","comments":true,"path":"posts/archives/60549.html/","link":"","permalink":"http://example.com/posts/archives/60549.html/","excerpt":"","text":"hexo博客踩坑记录前言本文用于记录博客搭建过程中遇到的问题及解决办法 1.hexo d后 ERROR Deployer not found: gitnpm install `--`save hexo-deployer-git 即可 参考文献：hexo d后 ERROR Deployer not found: git 2.由于nodejs版本过高导致的部署报错在部署hexo博客时出现以下错误： 即： (node:10524) Warning: Accessing non-existent property &#39;lineno&#39; of module exports inside circular dependency (Use `node --trace-warnings ...` to show where the warning was created) 解决方案：将当前版本的nodejs进行降级到12.x版本即可 具体操作参考：windows如何把已安装的nodejs高版本降级为低版本(图文教程) 3.hexo的skura主题主页视频相关仅支持20M以下MP4格式的视频，这是目前的测试情况，没有找到解决方案。 4.hexo安装指令$ npm install -g hexo-cli","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo博客搭建","slug":"hexo博客搭建","permalink":"http://example.com/tags/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"author":"learnqiu"},{"title":"在实验室追完一部剧之后，我决定写一篇检讨","slug":"mind-movie-01","date":"2020-12-21T13:34:10.000Z","updated":"2020-12-23T13:47:26.735Z","comments":true,"path":"posts/archives/4152.html/","link":"","permalink":"http://example.com/posts/archives/4152.html/","excerpt":"","text":"在实验室追完一部剧之后，我决定写一篇检讨前言今天在实验室一口气追完了一部剧，没有学习和写论文，我决定写一篇检讨，来反思一下自己的行为。 正文首先对于在实验室追剧这件事，我觉得有必要反省下。因为为啥之前没有发现如此惬意的划水方式。没有被发现的风险的宝座再加上我熟练的分屏以及键盘操作，简直完美啊， 在此，我反省一下自己为啥之前没有发现这种操作。。。 好了，编不下去了。的确做的不对（在此反省1分钟），但是在写论文和学习之余“偶尔”放松一下，还是非常nice的。 后记附几张截图，来自《弥留之国的爱丽丝》 明天起我一定好好学习。 遁了。。。","categories":[{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"剧集","slug":"剧集","permalink":"http://example.com/tags/%E5%89%A7%E9%9B%86/"}],"author":"learnqiu"},{"title":"用Python的you-get工具下载b站视频","slug":"tech-python-01","date":"2020-12-21T08:47:42.000Z","updated":"2020-12-23T13:47:26.955Z","comments":true,"path":"posts/archives/51011.html/","link":"","permalink":"http://example.com/posts/archives/51011.html/","excerpt":"","text":"用Python的you-get工具下载b站视频前言本文主要介绍如何下载b站视频 使用前提需要在电脑上安装python工具，具体的下载及安装方法可以参考python官方下载。安装好python并完成环境配置就可以进行下面的步骤了。 you-get工具安装打开cmd命令行工具，具体可以使用win+R快捷键后输入“cmd”后回车即可。 在弹出的对话框中输入： pip install you_get 等待界面显示安装完毕即可 使用you-get工具下载b站视频首先在你需要保存视频的文件夹下打开cmd命令，在对话框中输入： you-get b站视频链接 注意中间有空格 执行后等待命令执行完毕即可，效果如下：","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"learnqiu"},{"title":"hexo博客搭建记录","slug":"tech-hexo-01","date":"2020-12-21T08:11:12.000Z","updated":"2021-03-09T13:41:41.734Z","comments":true,"path":"posts/archives/46522.html/","link":"","permalink":"http://example.com/posts/archives/46522.html/","excerpt":"","text":"1.hexo博客搭建记录参考文献： hexo安装官方文档 Hexo重装与位置移动 免费CDN：jsDeliver-Github-搭建过程记录 前言本文用于记录常用指令，方便平时维护使用。 什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装安装 Hexo 只需几分钟时间，只需按教程进行安装即可， 安装前提 Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本) Git 如果您的电脑中已经安装上述必备程序，请直接前往hexo安装步骤， 安装前准备（若前提满足则跳过此步）如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。 安装 Git Windows：下载并安装 git. Mac：使用 Homebrew, MacPorts 或者下载 安装程序。 Linux (Ubuntu, Debian)：sudo apt-get install git-core Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core 安装 Node.jsNode.js 为大多数平台提供了官方的 安装程序。对于中国大陆地区用户，可以前往 淘宝 Node.js 镜像 下载。 其它的安装方法： Windows：通过 nvs（推荐）或者nvm 安装。 Mac：使用 Homebrew 或 MacPorts 安装。 Linux（DEB/RPM-based）：从 NodeSource 安装。 其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的 指导 对于 Mac 和 Linux 同样建议使用 nvs 或者 nvm，以避免可能会出现的权限问题。 安装 Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 $ npm install -g hexo-cli 进阶安装和使用对于熟悉 npm 的进阶用户，可以仅局部安装 hexo 包。 $ npm install hexo 安装以后，可以使用以下两种方式执行 Hexo： npx hexo &lt;command&gt; 将 Hexo 所在的目录下的 node_modules 添加到环境变量之中即可直接使用 hexo &lt;command&gt;： echo &#39;PATH=&quot;$PATH:./node_modules/.bin&quot;&#39; &gt;&gt; ~/.profile Node.js 版本限制我们强烈建议永远安装最新版本的 Hexo，以及 推荐的 Node.js 版本。 Hexo 版本 最低兼容 Node.js 版本 5.0+ 10.13.0 4.1 - 4.2 8.10 4.0 8.6 3.3 - 3.9 6.9 3.2 - 3.3 0.12 3.0 - 3.1 0.10 or iojs 0.0.1 - 2.8 0.10 2.Hexo重装与迁移备份只需要将source、themes、_config.yml进行备份即可 迁移更换一个位置进行部署后，只需要将source、themes、_config.yml覆盖到生成的新的博客文件根目录中就可以了 3.githubCDN图床更新上传将你要上传的图片视频保存到刚才那个本地文件夹中（上传的单个文件不要大于50M），然后在文件夹中右键Git Bash Here,执行一下命令： git status //查看状态 git add . //添加所有文件到暂存区 不要忘记后面那个. git commit -m &#39;提交信息&#39; //把文件提交到仓库 git push //推送至远程仓库 4.淘宝镜像（cnmp）的安装和使用打开cmd，输入（前提电脑中安装好了node.js） &quot;npm install -g cnpm --registry=https://registry.npm.taobao.org&quot; 之后就可以使用cnpm install -g ‘name’ 可进行全局安装了 参考文献：淘宝镜像（cnmp）的安装和使用","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo博客搭建","slug":"hexo博客搭建","permalink":"http://example.com/tags/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"author":"learnqiu"},{"title":"对hexo-sakura主题的回到顶部白猫图案进行自定义","slug":"tech-hexotheam-01","date":"2020-12-20T07:35:28.000Z","updated":"2020-12-23T13:47:26.852Z","comments":true,"path":"posts/archives/40028.html/","link":"","permalink":"http://example.com/posts/archives/40028.html/","excerpt":"","text":"对hexo-sakura主题的回到顶部白猫图案进行自定义前言sakura主题自带的回到顶部的图案非常好看，原始效果如下： 是一条绳子上面绑着一只可爱的白猫。 但是如何想自己进行回到顶部图案的自定义，该如何做呢？ 下面介绍具体的实现方法： 实现方法1.首先我们找到当前主题回到顶部图案设置的代码位置：你的博客\\themes\\Sakura\\source\\css\\style.css。打开后全局搜索.cd-top定位到图片链接区域，如下图所示： 2.打开这个链接，我们发现是一张图片，保存到你桌面备用。同时我们发现这张图片背景是透明的，尺寸为70*900。 因此想进行自定义，我们*只用自己制作一张70900的背景透明的图片替换原有的图片**就可以了。可以使用图片编辑工具，我使用的是一款在线ps工具，可以在里面对原始图片进行ps，生成新的图片。 3.制作一个70*900的背景透明图片，同时修改步骤一介绍的css代码块中的图片链接为新的图片路径。建议上传到图床后填写图片链接。 完成以上部分后，重新部署网站，就可以看到效果了。 实现效果以下是我自定义的回到顶部效果：","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo博客美化","slug":"hexo博客美化","permalink":"http://example.com/tags/hexo%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"}],"author":"learnqiu"},{"title":"博客上可以随便使用图片么？","slug":"mind-imgcopy-01","date":"2020-12-19T11:51:42.000Z","updated":"2020-12-23T13:47:26.716Z","comments":true,"path":"posts/archives/56930.html/","link":"","permalink":"http://example.com/posts/archives/56930.html/","excerpt":"","text":"博客上可以随便使用图片么？参考文献： 被罚了那么多钱，才知道真正免版权的图片素材是这些！ - 希尔瓦娜斯的文章 - 知乎 如何合法的使用一张图片 - 赵虎的文章 - 知乎 如何避免使用的图片存在侵权风险？ - 求职秘书的回答 - 知乎 收藏备用：60 余家免费正版图片网站，应该是目前最全的的集合了 - 马力在知群的文章 - 知乎 前言最近开通了个人博客，主页和文章配上了非常好看的图片。朋友提醒要关心图片的版权问题，便开始注意相关的信息，对于网站的图片使用相关问题，从网络上整理到如下内容： 网站图片使用相关问题一、相关科普1.《著作权法》第三条规定：图片和文字作品一样，都有版权，而版权就是著作权。 2.未经他人许可，使用他人有著作权的图片，可能构成著作权侵权。 3.免费下载不等于免费使用。 ​ 无协议：需征求作者同意，并标明图片来源。 ​ CC 协议：可以在不通知作者的情况下，“转载”、“使用”其作品。但是不允许：商业性使用、二次创作、改变授权方式的再次分享等行为。 ​ CC0 协议：代表作者完全放弃对其作品的所有著作权，理论上大家可以无条件使用。 二、如何正确使用图片 1.自己原创。这种情况不用担心侵权问题。 2.获得原作者授权。此方法虽好，但一般网络图片难以找到原作者。 3.通过购买图片权限进行使用。需关注购买到的具体使用权限范围。 4.使用CC协议的图片。可以在不通知作者的情况下，“转载”、“使用”其作品。但是不允许：商业性使用、二次创作、改变授权方式的再次分享等行为。 5.使用CC0协议的图片。代表作者完全放弃对其作品的所有著作权，理论上大家可以无条件使用。 6.合理使用。合理使用，是指可以不经著作权人许可，不向其支付报酬而使用已经发表的作品的情形，《著作权法》第22条对合理使用他人已经发表的作品进行了规定，包括12种法定情形。比如：个人学习、研究或者欣赏等等。 三、其他问题​ 1.在使用处标明”图侵删“是否就可以使用图片？ ​ 在原创文章中注明著作权归属或者作品来源，或者声明“侵删”，并不构成侵权免责。 ​ 2.为个人使用或不以盈利为目的，是否可以使用图片？ ​ 是否以盈利为目的，是否为个人使用均不能构成著作权侵权免责条款，但在认定侵权赔偿时，可以成为被考虑侵权赔偿数额的考虑因素。 四、在个人博客中应如何使用图片的建议​ 1.尽量使用原创图片。 ​ 2.选择CC0协议的图片。可以在有CC0协议的无版权网站中进行图片素材下载和使用。 五、无版权网站推荐来自知乎： Unsplash stocksnap shutterstock pngimg freejpg","categories":[{"name":"随想","slug":"随想","permalink":"http://example.com/categories/%E9%9A%8F%E6%83%B3/"}],"tags":[{"name":"博客如何正确使用图片","slug":"博客如何正确使用图片","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87/"}],"author":"learnqiu"},{"title":"Typora实现CMMS图床功能","slug":"tech-typora-01","date":"2020-12-19T11:25:27.000Z","updated":"2020-12-23T13:47:26.977Z","comments":true,"path":"posts/archives/5113.html/","link":"","permalink":"http://example.com/posts/archives/5113.html/","excerpt":"","text":"Typora实现CMMS图床功能前言通过之前的文章，我们可以通过配置typora实现图片插入后自动储存并生成图片代码。 但是这些图片资源，储存在本地，hexo发布时会一同打包到网站中去，长久下去整个网站资源会非常的臃肿，不便于维护。 因此，能否将文章的图片上传到图床中去，使用这些图片的文章只用引用这些图床的图片链接，从而解决这种图片打包到网站资源的问题。 Typora经过版本更新后，新增了图床连接的功能，文章插入图片后会自动上传至图床并生成图片连接，非常方便。 解决方案我是按照“史上最强markdown编辑器typora终于支持图床功能了！！！”这边教程进行配置的，主要的步骤如下: 1.注册smms，获取token 2.修改typora设置配置 实现效果插入图片时，会自动上传 上传成功后，自动生成图床图片链接 参考文献 史上最强markdown编辑器typora终于支持图床功能了！！！","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"learnqiu"},{"title":"Hexo+Typora实现图片插入文章后自动复制到指定文件夹及生成图片代码","slug":"tech-markdown-04","date":"2020-12-18T06:44:16.000Z","updated":"2020-12-23T13:47:26.932Z","comments":true,"path":"posts/archives/46779.html/","link":"","permalink":"http://example.com/posts/archives/46779.html/","excerpt":"","text":"Hexo+Typora实现图片插入文章后自动复制到指定文件夹及生成图片代码前言很多朋友都是使用Typora来编写Hexo文章的，我们可以通过设置hexo和Typora来实现编写hexo博客时轻松插入和管理图片。 实现方法1.在hexo博客的hexo/source目录下新建一个post-images文件夹用于储存文章图片资源 2.打开Typora软件，在文件-&gt;偏好设置-&gt;图像中进行设置，如下: hexo文章默认路径在`hexo/_posts文件夹下，其中使用的指定路径为： ../../source/post-images/$&#123;filename&#125; 若你的文章存储路径不一致，对应的指定路径也需要更改，目的是定位到新建的图片资源文件夹中，../表示返回上级目录。 3.为保证部署到服务器后，能正常访问，还需要在Typora设置图片根目录，以保证生成的路径支持服务器解析。操作为：在Typora中，点击格式-&gt;图像-&gt;设置图像根目录，在弹出的对话框中将hexo博客/source作为其根目录。 完成以上操作即可实现hexo图片的轻松插入和管理了。 实现效果截图复制图片，在文章位置中粘贴图片，效果如下： 同时对应图片会复制到hexo博客/source/post-images/文章名文件夹中 非常方便 参考文献 typora + hexo博客中插入图片 后记接下来会写一篇关于typora+图床实现插入图片自动上传的文章介绍","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo博客写作","slug":"hexo博客写作","permalink":"http://example.com/tags/hexo%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C/"},{"name":"Typora","slug":"Typora","permalink":"http://example.com/tags/Typora/"}],"author":"learnqiu"},{"title":"在Typora中如何配置图片插入自动存放到指定位置并生成图片代码","slug":"tech-markdown-03","date":"2020-12-18T05:55:56.000Z","updated":"2020-12-23T13:47:26.910Z","comments":true,"path":"posts/archives/40059.html/","link":"","permalink":"http://example.com/posts/archives/40059.html/","excerpt":"","text":"在Typora中如何配置图片插入自动存放到指定位置并生成图片代码前言使用markdown在文章中插入指定的图片时，图片来源一般分为以下几种： 本地图片：截图和下载到本地的图片 网络图片：网络链接表示的图片 图片插入时，步骤比较复杂： 插入图片代码-&gt;填入本地或者网络路径 这样的操作首先对文章的图片没有集中管理，链接的都是图片原地址，原图丢失文章就无法显示对应图片。对于网络图片的话，还会受图片所在网络服务器的影响，加载较慢。 配置方法Typora对于这种问题有了很好的解决方案，通过简单的配置就可以实现只用将图片复制到文章中，就能实现: 图片备份到指定文件夹 自动插入图片代码 配置步骤如下： 1.在工具栏选择文件-偏好设置。 2.在弹出的偏好设置窗口中，选择图像，并勾选前三项。 ​ 同时对备份的路径进行设置， ​ 无特殊操作（不能选择这个）：代表插入图片时不复制图片，使用图片原地址 ​ 复制开头的三个选项：在三个中进行选择，来设置图片复制路径。 设置完毕后，此功能就启用了。是不是很简单的配置。 实现效果配置完毕后，我们分别对本地和网络图片进行设置。我复制路径设置的为**./${filename**，代表着图片复制到文章所在目录下面与文章名同名的文件夹中。你们可以根据自己要求来设置。 本地图片： 1.截图：使用qq自带截图工具进行截图，点击完成，图片会自动复制 在文章中选择指定位置进行粘贴，效果如下： 自动生成图片代码 复制图片到指定路径 2.复制本地图片：效果与截图完成后一致，不再赘述。 网络图片 在网络上找到指定的图片，右击选择复制图片 在文章中选择指定位置进行粘贴，效果如下： 同时图片也会自动复制到指定位置 后记over，下篇文章会介绍hexo+typora实现hexo编写文章轻松插入图片。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo博客写作","slug":"hexo博客写作","permalink":"http://example.com/tags/hexo%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C/"},{"name":"Typora","slug":"Typora","permalink":"http://example.com/tags/Typora/"}],"author":"learnqiu"},{"title":"这是我的转载","slug":"copy-mycopy","date":"2020-12-17T12:48:21.000Z","updated":"2020-12-23T13:47:26.681Z","comments":true,"path":"posts/archives/29603.html/","link":"","permalink":"http://example.com/posts/archives/29603.html/","excerpt":"","text":"这是我的转载未完待续。。。","categories":[{"name":"转载","slug":"转载","permalink":"http://example.com/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[],"author":"learnqiu"},{"title":"这是我的随想","slug":"mind-mymind","date":"2020-12-17T12:47:30.000Z","updated":"2020-12-23T13:47:26.799Z","comments":true,"path":"posts/archives/18029.html/","link":"","permalink":"http://example.com/posts/archives/18029.html/","excerpt":"","text":"这是我的随想未完待续。。。","categories":[{"name":"随想","slug":"随想","permalink":"http://example.com/categories/%E9%9A%8F%E6%83%B3/"}],"tags":[],"author":"learnqiu"},{"title":"这是我的资源","slug":"download-mydl","date":"2020-12-17T12:46:17.000Z","updated":"2020-12-23T13:47:26.699Z","comments":true,"path":"posts/archives/64744.html/","link":"","permalink":"http://example.com/posts/archives/64744.html/","excerpt":"","text":"这是我的资源未完待续。。。","categories":[{"name":"资源","slug":"资源","permalink":"http://example.com/categories/%E8%B5%84%E6%BA%90/"}],"tags":[],"author":"learnqiu"},{"title":"这是我的图集","slug":"photo-myphoto","date":"2020-12-17T12:36:46.000Z","updated":"2020-12-23T13:47:26.784Z","comments":true,"path":"posts/archives/41636.html/","link":"","permalink":"http://example.com/posts/archives/41636.html/","excerpt":"","text":"这是我的图集未完待续。。。","categories":[{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"图集","slug":"图集","permalink":"http://example.com/tags/%E5%9B%BE%E9%9B%86/"}],"author":"learnqiu"},{"title":"这是我的书单","slug":"book-mybook","date":"2020-12-17T12:36:17.000Z","updated":"2020-12-23T13:47:26.654Z","comments":true,"path":"posts/archives/31444.html/","link":"","permalink":"http://example.com/posts/archives/31444.html/","excerpt":"","text":"这是我的书单未完待续。。。","categories":[{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"http://example.com/tags/%E6%82%A6%E8%AF%BB/"}],"author":"learnqiu"},{"title":"Typora：推荐一款简洁的Markdown编辑器","slug":"tech-markdown-02","date":"2020-12-17T06:15:12.000Z","updated":"2020-12-23T13:47:26.884Z","comments":true,"path":"posts/archives/7629.html/","link":"","permalink":"http://example.com/posts/archives/7629.html/","excerpt":"","text":"Typora：推荐一款简洁的Markdown编辑器Typora介绍下载及安装官网入口：Typora 下载地址：Windows版本 Linux版本 前言如果你和我一样： ​ 喜欢简洁的风格 ​ 有着文艺的内心 ​ 注重美观的感受 ​ 希望所见即所得 那么恭喜你发现宝藏 Typora 什么是Typora Typora是一款轻便简洁的Markdown编辑器 它删除了预览窗口、模式切换器、Markdown源代码的语法符号以及所有其他不必要的干扰。同时，它提供了真正的实时预览功能，可帮助您专注于内容本身。 即时渲染技术所见即所得。即时渲染技术就是说你写Markdown就像和写Word文档一样，文本样式即时展示，不需要提交到Markdown浏览工具进行预览。 免费对，没错这是一款免费的Markdown编辑工具 界面简洁下面是Typora的界面，简洁、简洁还是简洁，是不是感觉自己打开了自带的文本编辑器 基本功能及时渲染实时展示图片、标题、列表、表格、代码块、数学公式、图表及基本内联样式等等。。。 1.图片及标题 2.列表及表格 3.代码片段 可以选择语言进行涂色 4.内联样式 下面是来自官网的介绍截图，还是比较丰富的 5.其他 也支持显示其他的内容，比如数学公食、图表等，不常用，大家可以自己下载安装后探索 快捷键操作对于文档编辑时进行的样式操作提供快捷键，使用起来非常方便 1.段落操作 2.格式操作 辅助功能整理档案Typora可让您轻松管理文件，同时提供文件树面板和文章（文件列表）侧面面板，可让您轻松管理文件。以自己的方式整理文件，包括放入同步服务，例如Dropbox或iCloud。 轮廓面板在大纲面板中自动查看文档的大纲结构，使您可以快速浏览文档并单击一下即可跳至任何部分。 导入导出可导出为PDF。支持导出或导入更多格式，包括docx，OpenOffice，LaTeX，MediaWiki，Epub等。 字数查看文档的字数，字符，行数或阅读分钟数。 对焦模式和打字机模式聚焦模式可以使其他行模糊，从而仅使您聚焦于当前行。打字机模式始终将当前活动的行保持在窗口中间。 自动配对自动完成一对括号和引号，就像代码编辑器一样。此外，还有一个选项可以自动配对降价符号，例如*或_。 自定义主题提供五款默认主题自由选择，个人比较喜欢系统默认的github主题 好了，以上就是Typora的全部介绍内容了，更多的功能可以自己去探索哦。也可以前往官网了解 参考文献 Typora官网 后记关于Typora如果在粘贴图片时进行图片自动路径保持及图片代码生成，接下来我会再出一个帖子进行介绍","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo博客写作","slug":"hexo博客写作","permalink":"http://example.com/tags/hexo%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C/"},{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/tags/Markdown/"}],"author":"learnqiu"},{"title":"用hexo编写文章，来学学简单的Markdown语法吧","slug":"tech-markdown-01","date":"2020-12-16T12:42:36.000Z","updated":"2020-12-23T13:47:26.868Z","comments":true,"path":"posts/archives/7188.html/","link":"","permalink":"http://example.com/posts/archives/7188.html/","excerpt":"","text":"本文主要介绍hexo简单的Markdown语法 这是本站第一篇文章，如有疏漏，可随时指正哦 hexo简单的Markdown语法1.1 斜体和粗体写法： *这是斜体* 或 _这也是斜体_ **这是粗体** ***这是加粗斜体*** ~~这是删除线~~ 效果：这是斜体 或 这也是斜体这是粗体这是加粗斜体这是删除线 1.2 分级标题写法： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 效果： 1.3 超链接写法： 行内形式：[我的博客](https://kevinpu.github.io/) 参考形式：[我的博客][1]，[我的网站][2] [1]:https://learnqiu.github.io/ [2]:http://www.learnqiu.qiu/ 自动链接：我的博客地址&lt;https://learnqiu.github.io/&gt; 效果：行内形式：我的博客参考形式：我的博客，我的网站 自动链接：我的博客地址https://learnqiu.github.io/ 1.4 图片资源图片素材按官方教程说法，可统一放置在source/images目录中，引用方式如下： ![](/images/image.jpg) 效果： 1.5 插入代码片段写法： /忽略此处/ ``` bash 代码片段内容 /忽略此处/ ``` 效果： 代码片段内容 目前，只是介绍了一些简单的语法，后续会逐渐更新更多语法内容~ 参考文献 [用Hexo写出第一篇博客][https://www.jianshu.com/p/56d99a3049a5]","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo博客写作","slug":"hexo博客写作","permalink":"http://example.com/tags/hexo%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C/"},{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/tags/Markdown/"}],"author":"learnqiu"}],"categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"},{"name":"随想","slug":"随想","permalink":"http://example.com/categories/%E9%9A%8F%E6%83%B3/"},{"name":"转载","slug":"转载","permalink":"http://example.com/categories/%E8%BD%AC%E8%BD%BD/"},{"name":"资源","slug":"资源","permalink":"http://example.com/categories/%E8%B5%84%E6%BA%90/"}],"tags":[{"name":"word","slug":"word","permalink":"http://example.com/tags/word/"},{"name":"面试准备","slug":"面试准备","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"},{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"NPOI","slug":"NPOI","permalink":"http://example.com/tags/NPOI/"},{"name":"excel工具类","slug":"excel工具类","permalink":"http://example.com/tags/excel%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"文件操作类","slug":"文件操作类","permalink":"http://example.com/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%B1%BB/"},{"name":"NGSA-2","slug":"NGSA-2","permalink":"http://example.com/tags/NGSA-2/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"遗传算法","slug":"遗传算法","permalink":"http://example.com/tags/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"},{"name":"车间调度问题","slug":"车间调度问题","permalink":"http://example.com/tags/%E8%BD%A6%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/"},{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"NSGA-II","slug":"NSGA-II","permalink":"http://example.com/tags/NSGA-II/"},{"name":"pareto","slug":"pareto","permalink":"http://example.com/tags/pareto/"},{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"},{"name":"随想","slug":"随想","permalink":"http://example.com/tags/%E9%9A%8F%E6%83%B3/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"},{"name":"ORACLE","slug":"ORACLE","permalink":"http://example.com/tags/ORACLE/"},{"name":"剧集","slug":"剧集","permalink":"http://example.com/tags/%E5%89%A7%E9%9B%86/"},{"name":"hexo博客搭建","slug":"hexo博客搭建","permalink":"http://example.com/tags/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"hexo博客美化","slug":"hexo博客美化","permalink":"http://example.com/tags/hexo%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"},{"name":"博客如何正确使用图片","slug":"博客如何正确使用图片","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87/"},{"name":"hexo博客写作","slug":"hexo博客写作","permalink":"http://example.com/tags/hexo%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C/"},{"name":"Typora","slug":"Typora","permalink":"http://example.com/tags/Typora/"},{"name":"图集","slug":"图集","permalink":"http://example.com/tags/%E5%9B%BE%E9%9B%86/"},{"name":"悦读","slug":"悦读","permalink":"http://example.com/tags/%E6%82%A6%E8%AF%BB/"},{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/tags/Markdown/"}]}